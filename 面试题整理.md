面试题整理

## HTML+CSS

### 说说flex布局

Flex（Flexible Box），也就是”弹性布局”，它可以很灵活地实现垂直居中、多列布局等自适应问题。而任何一个容器都可以指定为Flex布局。设为Flex布局以后，子元素的`float、clear和vertical-align`属性将失效。

### 介绍一下盒模型

①盒模型：内容(content)、填充(padding)、边界(margin)、 边框(border)

②类型： IE 盒子模型、标准 W3C 盒子模型；

③两种盒模型的主要区别是:标准盒模型的宽高是值内容宽高(content) 

④而IE盒模型的宽高是指content+padding+border。

 ⑤设置盒模型的方式是：设置box-sizing

 `box-sizing:content-box`  标准盒模型， 

`box-sizing:border-box` IE盒模型

### HTML5语言化及好处

什么是语义化？就是用合理、正确的标签来展示内容，比如h1~h6定义标题。

好处
`易于阅读`，样式丢失的时候能让页面呈现清晰的结构。

`有利于SEO`，搜索引擎根据标签来确定上下文和各个关键字的权重。

`方便其他设备解析`，如盲人阅读器根据语义渲染网页

`有利于开发和维护，语义化更具可读性，代码更好维护`，与CSS3关系更和谐。

### 使用过哪些语义化的标签

1、语义化标签： nav header footer aside、

2、表单新特性：process 进度条 datalist 数据列表 meter刻度尺 output 输出内容

表单元素的新属性：placeholder 占位提示文字  mutiple 是否允许多个输入  autofocus自动获得输入焦点  required 输入框不能为空 

Max允许输入的数字的最大值 min minlength 允许输入的字符串最小长度 maxlength pattern 输入框内容必须符合正则表达式

1、音频<audio>和视频<video>

2、拖放API

​	拖动的源对象(source)可能触发的事件：

​                dragstart：拖动开始

​                 drag：拖动中

​                 dragend：拖动结束

​             拖动的目标对象(target)可能触发的事件：

​                    dragenter：拖动进入

​                    dragover：拖动悬停

​                    drop：松手释放

​                    dragleave：拖动离开

### img中alt和元素的title属性作用

img的alt属性如果无法显示图像，浏览器将显示alt指定的内容

元素title属性在鼠标移到元素上时显示title的内容

### rgba和opacity的区别

  opacity会`继承`父元素的 opacity 属性，而rgba设置的元素的后代元素`不会继承`不透明属性。

### 图片底部3像素空白

出错原因：所有的行内块元素(img图片为行内块)的一个属性，默认情况下是基线对齐，vertical-align：baseline

解决办法：1、设置vertical-align的值不是baseline就可以（middle、top、bottom）

​		 2、行内块元素转块元素

### 如何解决一像素的问题

<https://segmentfault.com/a/1190000016116868?utm_source=tag-newest>

​	原因：因为在移动端，由于屏幕分辨率的不同，`在``不同的分辨率上，有可能一像素被渲然成二个像素点或者三个像素点``，所以在实际写代码的时候，我们写的 border: 1px solid #000; 可能实际被渲然为 2px/3px；

​	解决：

​	1、`使用border-image来代替border`

```css
.border-image-1px {
    border-width: 1px 0px;
    -webkit-border-image: url("border.png") 2 0 stretch;
    border-image: url("border.png") 2 0 stretch;
}
```



​	2、`伪类 + transform` 实现（先使用伪类元素实现边框效果，然后通过媒体查询来操控transform：scale(缩放)来适配不同分辨率）

```css
    .border-bottom{
        position: relative;
    }
    .border-bottom::after {
        content: " ";
        position: absolute;
        left: 0;
        bottom: 0;
        width: 100%;
        height: 1px;
        background-color: #e4e4e4;
        -webkit-transform-origin: left bottom;
        transform-origin: left bottom;
    }

    /* 2倍屏 */
    @media only screen and (-webkit-min-device-pixel-ratio: 2.0) {
        .border-bottom::after {
            -webkit-transform: scaleY(0.5);
            transform: scaleY(0.5);
        }
    }

    /* 3倍屏 */
    @media only screen and (-webkit-min-device-pixel-ratio: 3.0) {
        .border-bottom::after {
            -webkit-transform: scaleY(0.33);
            transform: scaleY(0.33);
        }
    }
```



3、viewport + rem 实现

4、通过项目中引入border.css来解决

### 清除浮动有哪些？原理是什么

​	1、给父级定义height

​	2、结尾处加空div标签 clear：both

​	3、父级div定义 伪类：after 和zoom,定义公共类

```css
        /*清除浮动代码*/ 
        .clearfix：after{
        content：""；//必须
        display：block；//必须
        visibility：hidden；
        height：0；
        line-height：0；
        clear：both；//必须
        } 
        .clearfix{zoom：1} //兼容ie6、7的浮动问题
```

​	4、父级div定义overflow:hidden(不建议使用，超出盒子部分会隐藏)

​	5、双伪元素法

```css
.clearfix：before，.clearfix：after {
			content： ""；
			display： block；
			clear： both；
		}
		.clearfix {
			zoom： 1；
		}
```

`原理是：BFC`

### BFC块级格式化上下文( 谈谈你对pc端布局的理解？实现的原理是什么

BFC是一个**`独立的渲染区域`**，他规定了在该区域中，常规流块盒的布局

- 独立=>不同的BFC区域，它们进行渲染的时候 互不干扰

  - 创建了BFC的元素，隔绝了它`内部与外部的联系，内部的渲染不会影响到外部`

  - **具体规则**：

     创建BFC的元素：`它的自动高度需要计算浮动元素`

     创建BFC的元素：`它的边框盒不会与浮动元素重叠`

    ​	根据这个效果，可以做很多一边固定一边自适应的布局，也可以做多边固定，一边自适应。比如：圣杯布局，双飞翼布局，都可以使用这个特性进行布局。

    创建BFC的元素：`不会和它的子元素进行外边距合并`

    ​	根本原因:

     	根元素html元素会创建BFC

     	父元素处于的上下文是根元素创建的BFC上下文

     	子元素处于的上下文是父元素创建的BFC上下文

     	他们处于不同的BFC上下文，而BFC是独立的渲

     	染区域。所以他们两个的渲染是互不干扰的，因此

     	他们的外边距是不能合并的

这个区域由某个HTML元素创建，常用的 常见的 会在内部创建BFC区域的元素：

- 根元素（html）
- 浮动，绝对定位，固定定位元素
- overflow不等于visible的块盒

一个新的 `display` 属性的值，它可以创建无副作用的BFC。在父级块中使用 `display: flow-root` 可以创建新的BFC。

浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠也只会发生在属于同一BFC的块级元素之间

### 哪些元素会生成BFC

​     A.根元素（html）

​     B. 浮动 float属性不为none

​     C. 绝对定位，固定定位元素  position为absolute或fixed

​     D. display为inline-block， table-cell， table-caption， flex， inline-flex

​     F. overflow不为visible

### 谈谈css 的display的几个属性的区别，各个属性常见的标签。谈谈block 的外边距（外边距塌陷），你是怎么解决这个问题的

`display:block`

块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote 

块级元素的特点： 1.总在新行上开始，`占据一整 行` 

​			      2`可设置宽高`

​			      3.宽度始终是与浏览器宽度一样，与内容无关 

​			      4`.它可以容纳行内元素和其他块元素`

​			      5.块级元素的垂直相邻外边距margin会合并。 

`dispaly:inline`

行内元素：a、b、span、strong、select、label、em、button、textarea 

行内元素的特点： 1. `和其他元素都在一行`上 

​				2. `不可以设置宽高`，其宽 度随着内容增加，高度随字体大小而改变

​				 3.宽度只与内容有关 

​				4.行内元素只能容纳文本 或者其他行内元素 

`水平方向`的padding-left、padding-right、margin-left、margin-right都`产生边距效果`， `但竖直方向的` padding-top、padding-bottom、margin-top、margin-bottom却不会产生边距效果。`内联元素可以设置外边界`，但是外边界不对上下起作用，只能对左 右起作用。 

空元素:br、meta、hr、link、input、img 空元素的特点： 

1.没有内容的 HTML 内容被称为空元素。空元素是在开始标签中关闭的。br 就是没有关闭标签的空元素 

2.在 XHTML、XML 以及未来版本的 HTML 中，所有元素必须被关闭。 

3.在开始标签中添加斜杠，比如 < br />，是 关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。 

`外边距塌陷`

```1\
1.为父盒子设置1像素的上边框,颜色一样，但是会撑大父盒子，所以父盒子高度减
2：父盒子设置overflow：hidden ，触发bfc ,不会撑大盒子
3.为子盒子设置1像素的上内边距，也会撑大子盒子，所以子盒子高度减1
```

###  position的属性值有哪些？区别是什么

position：static（默认情况下）、relative（相对定位），absolute（绝对定位），fixed（固定定位）

共同点 :

(1) absolute、fixed改变行内元素的呈现方式，display被置为block； 

(2)absolute、fixed， 让元素脱离标准流，不占据空间； relative和static不脱离标准流，占位置

(3) 默认会覆盖到非定位元素上 

不同点： 

`absolute的定位是根据父级元素的`，子绝父相，如果父级没设置，则是根据body，而`fixed的”根元素“固定为浏览器窗口`。 当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。 

### 实现垂直水平居中

1、弹性盒子：·

​	父盒子设置 dispaly ：flex；

​	主轴和纵轴justify-content：center；align-items：center；

2.定位：（宽高固定）

​	设置父盒子 相对定位  子盒子 绝对定位

​	left 50%；top 50%； 之后  分别移动自身的一半 margin-left：-宽度的一半；margin-top：-高度的一半；

3.定位：（宽高不固定）

​	设置父盒子 相对定位   子盒子 绝对定位  

​	left 50%；top 50%； 之后  分别用移动自身的一半：transform: translate(-50%, -50%);

4.定位 （宽高固定）

​	父盒子 position: relative;子盒子设置宽高，

​	position: absolute; left: 0;right: 0; top: 0; bottom: 0;margin: auto;

5、padding，margin硬挤

###  link和@import的区别

`link外链 import导入` 

区别2：link引用CSS时，在页面载入时`同时加载`；@import需要页面`网页完全载入以后加载`。 

区别3：link是XHTML标签，`无兼容问题`；@import是在CSS2.1提出的，低版本的浏览器不支持。 

区别4：link支持使用`Javascript控制DOM去改变样式`；而@import不支持。 

### src和href的区别

**href**是Hypertext Reference的缩写，表示**超文本引用**。**用来建立当前元素和文档之间的链接**。常用的有：link、a。

<link href="reset.css" rel="stylesheet"/>

浏览器会`识别该文档为css文档，并行下载该文档，并且不会停止对当前文档的处理`。这也是建议使用link，而不采用@import加载css的原因。

src是source的缩写，**src的内容是页面必不可少的一部分，是引入**。**`src指向的内容会嵌入到文档中当前标签所在的位置`**。常用的有：img、script、iframe。
`当浏览器解析到该元素时，会暂停浏览器的渲染，直到该资源加载完毕。`这也是将js脚本放在底部而不是头部得原因。

`src用于替换当前元素；href用于在当前文档和引用资源之间建立联系`。

### css三大特性

层叠性：1、必须是相同的选择器
		2、当发生样式冲突时，后面的定义样式会覆盖前面的样式

继承性：1、在嵌套结构中，若子元素没有默认的设置样式，则子元素继承父元素的属性，若有默认样式，会被默认样式层叠掉

​	 	2、可继承属性：color，font的属性，text属性，line-height行高

​		3、不可继承属性：背景颜色不可以继承，padding，margin，display等

优先级：标签选择器<类选择器<id选择器<行内样式<！important 

		继承的优先级为0，若标签自己设置了样式，则继承的标签样式会被覆盖

### css3新特性

新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点） 

圆角 （border-radius:8px） 

多列布局 （multi-column layout） 

阴影和反射 （Shadow\Reflect） 

文字特效 （text-shadow、） 

文字渲染 （Text-decoration） 

线性渐变 （gradient） 

旋转 （transform） 

增加了旋转,缩放,定位,倾斜,动画，多背景 

transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation: 

###  如何区分html和html5

DOCTYPE声明变化： HTML4中需要指明是HTML的哪个版本，HTML5不需要，只使用即可。 

原因：

HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；
HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。

新增的元素和废除的元素 

### 伪类和伪元素的区别

伪类（单冒号）“： ”表示`已存在`的某个元素`处于某种状态`，但是通过dom树又无法表示这种状态，`可以通过伪类来为其添加样式`。：link  :visited :hover :active :focus :checked ：nth-child()

伪元素（双冒号）“：： ” 主要用于`创建一些不存在`于Dom结构树中的元素，不以元素位最小选择单位，她选择的是元素指定内容。例如：用：：before和：：after在一些存在的元素中添加样式或图标。 ::before ::after 

### break和continue的区别

1、break用于`结束整个循环`

2、continue用于`结束整个循环中的一次`，结束当前这次循环

3、break和continue后面的代码都不会执行，执行前面的代码

### 标准模式和怪异模式的区别

1、盒模型的处理差异：怪异模型为iE盒模型。宽高包括padding+content+border 标准的为W3C盒模型

2、行内元素的垂直对齐	vertical-align

​	标准模式下基于基线对齐

​	怪异模式下基于底部对齐

### HTML5中的本地存储概念是什么？声明周期有多长

cookies兼容所有的浏览器，Html5提供的storage存储方式。

​					       容量					有效期											作用域

①　Document.cookie	不能超过4k	只`在设置的cookie过期时间之前一直有效`，即使窗口或浏览器关闭	在所有同源窗口中都是共享的

②　Window.localstorage	约20M	`始终有效，窗口或浏览器关闭也一直保存`，因此用作持久数据		所有同源窗口中都是共享的

③　Window.sessionstorage	约5M	仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持	在不同的浏览器窗口中不共享，即使是同一个页面

cookie数据始终在`同源的http请求中携带`（即使不需要），即`cookie在浏览器和服务器间来回传递`。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。

相关的一些方法详解

setItem(key， value) 设置存储内容

getItem(key) 读取存储内容

removeItem(key) 删除键值为key的存储内容

clear() 清空所有存储内容

key(n) 以索引值来获取存储内容

### cookie和session的区别

​	在网站中，http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。cookie的出现就是为了解决这个问题`，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器`，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据。

​	session和cookie的作用有点类似，都是为了存储用户相关的信息。不同的是`，cookie是存储在本地浏览器，而session存储在服务器`。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源，但现在服务器已经发展至今，一些session信息还是绰绰有余的。

​	`cookie和session的结合使用`

1、存储在服务端：`通过cookie存储一个session_id，然后具体的数据则是保存在session中`。如果用户已经登录，则服务器会在cookie中保存一个session_id，下次再次请求的时候，会把该session_id携带上来，服务器根据session_id在session库中获取用户的session数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。这种专业术语叫做server side session。

2、将session数据加密，然后存储在cookie中。这种专业术语叫做client side session。flask采用的就是这种方式，但是也可以替换成其他形式。

## JS基础

### javaScript是什么

JavaScript： 基于对象和事件驱动，运行在浏览器客户端的脚本语言

### 页面上有一万个button如何绑定事件

给父元素进行事件委托，以事件冒泡，根据e.target判断是哪个button做了委托

### 事件流

1、一个完整的JS事件流是从window开始，最后回到window的一个过程
2、事件流被分为三个阶段`事件捕获阶段、目标阶段、冒泡阶段`

`事件冒泡`：最先触发目标阶段->document

在事件发生后，事件会从目标元素开始一直冒泡到document

`事件捕获：`document->目标阶段

### e.target和e.currentTarget

e.target和currentTarget都是event上面的属性，target是真正发生事件的DOM元素（`最先触发的元素`），而currentTarget是`当前事件发生在哪个DOM元素`上。

`e.target和this的区别`

this在事件处理程序中始终代表的是`事件源`

e.target 代表不一定是事件源，代表的是最先触发的元素（例如事件委托）

**IE只支持事件冒泡**。

### 事件冒泡，事件委托 

`事件冒泡：`

子节点和父节点注册了同名事件，当点击子节点时，由子节点向父节点去触发同名事件，父节点的事件也会执行

`事件委托：`

不在事件的发生地（直接dom）上设置监听函数，而是在其`父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发`，通过判断事件发生元素DOM的类型，来做出不同的响应。

步骤：1、给子孙元素的上级注册事件

​	   2、使用 事件对象.target 可以找到最先触发事件的元素

​	  3、判断 e.target 找到的元素是否是要找的元素，用nodeName（获得大写标签名）判断

原理：事件冒泡到上级，使用e.target找到最先触发的元素

优点：节省内存，减少事件绑定，可以动态的添加事件

注意：``委托是下级元素委托上级元素`

使用场景：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。

兼容性：兼容低版本的IE：window.event    var ev = e||window.event

### 事件对象

事件对象，在事件触发后，在事件处理程序中（函数体），所获取并操作的对象

事件对象：事件发生时的相关信息对象【`event,ev,e`】

`获取事件对象`：事件源.事件类型 = function(e){  // 第一个形参e就是事件对象    }

### 鼠标事件对象相关属性

- 事件对象.clientX   /    事件对象.clientY    参照是==浏览器== 

- 事件对象.pageX   /    事件对象.pageY    参照是==文档== 

- 事件对象.offsetX   /    事件对象.offsetY    参照是==当前的元素==

  

### 键盘事件对象相关属性

事件对象.keyCode     获取键盘按键对应的键码值

事件对象.altKey         表示alt键是否按下，返回布尔值

事件对象.shiftKey       表示shift键是否按下，返回布尔值

事件对象.ctrlKey        表示ctrl键是否按下，返回布尔值。（true按下，false没有按下）

### 如何阻止事件冒泡和默认事件

`事件对象.preventDafault()` 阻止默认行为

`事件对象.stopPropagation()` 停止事件冒泡

```js
function stopBubble(e) 
{ 
if (e && e.stopPropagation) 
e.stopPropagation() 
else 
window.event.cancelBubble=true 
} 
return false
e.preventDefault()
```

### js怎么控制一次加载一张图片，加载完后再加载下一张

监控到图片是否加载完成 就能实现

```js
<script type="text/javascript">
    let img = new Image();
    img.src="https://ss3.baidu.com/-rVXeDTa2gU2pMbgoY3K/it/u=2338809465,934935445&fm=202&src=608&mola=new&crop=v1";
    img.onload = function () {
        alert('图片的宽为：'+img.width+'；图片的高度为：'+img.height);
        document.getElementById("mypic").innerHTML="<img src='"+this.src+"'/>";
    }
</script>
<div id="mypic">onloading....</div>
```

### js数据类型有哪些

简单数据类型：Number,String,Boolean,null,undefined

复杂数据类型：Object

### null和undefined的区别

相同点：在if判断语句中，值都默认为false

不同点： 

1 null转化为数字类型值为0，undefined转化为数字类型为NaN 

2 在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined 

3 null值则是表示`空对象指针`。 

null是关键字，可以认为是对象类型，它是一个空对象指针，和其它语言一样都是代表“空值”，

`null的使用场景`：

​	可以作为原型链的终点。

​	作为函数的参数，表示该函数的参数不是对象

undefined 却是javascript才有的。为了区分空指针对象和未初始化的变量，它是一个预定义的全局变量。

`undefined的使用场景`

没有返回值的函数返回为undefined，

没有实参的形参也是 undefined

变量被声明，但没有赋值

对象没有赋值的属性，该属性的值为undefined

### 数据类型的转换

`强制类型转换` 

​	Number（） 结果：数字或NAN

​	parseInt（）结果：1、字符串前面时数字，可以把前面转为数字类型	2、字符串中前面不是数字，转NaN

​	parseFloat() 结果：同上

​	String（）

​	toString()  undefined 和 null 不能使用这个方式变为字符串

​	Boolean（） 结果：true或false

`隐式类型转换`

转成String类型，+字符串 字符串拼接

转number类型： ++ --

转Boolean类型：！

### 简单数据类型和复杂数据类型（普通类型和引用类型）

1、简单类型数据存储在内存的栈空间中，复杂类型的数据存储在内存的堆空间中，栈用来存地址

`简单类型：`

​	1、把一个变量赋值给另一个变量的时候，其实是把`栈空间的数据`(格子内的值复制了)复制了一份

​	2、简单类型的的变量赋值给另一个变量，当另一个变量改变了，不会影响原来的变量

`复杂类型：`

​	1、复杂类型在内存的储存，赋值给其他变量，也是把栈中的内容复制了一份，相当于`两个对象内容存的是同一份地址`

​	2、当改变一个变量时，修改的是同一个堆内存地址上的数据，所以obj1和obj2修改的其实是同一个对象

### 形参和实参

形参：在定义函数时写的占位用的参数

实参：在调用函数中，实际参与函数执行的真实的参数

### return的作用

1、修改函数的返回值，若后面有值，则返回，若没有，默认还是undefined

2、终止函数的执行

### 什么是伪数组

arguments 这个东西看起来**样子像数组**，但是其实不是一个数组，我们管它叫 `伪数组`。它具有数组的长度和顺序等特征。本质为对象。

```js
无法直接调用数组方法或期望length属性有什么特殊的行为，不具有数组的push,pop等方法，但仍可以对`真正数组遍历方法来遍历它们`。
典型的是函数的argument参数，还有像调用getElementsByTagName,document.childNodes之类的,它们都返回NodeList对象都属于伪数组。
可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。
```

应用场景：**当我们不知道我们的参数个数的时候**；

### 伪数组转化为真数组

1、声明一个空数组，通过遍历将他们添加到新的数组中去

2、使用数组的slice()方法，返回的是数组，使用call或者apply指向伪数组

```js
var arr = Array.prototype.slice.call(oldarr);
```

3、Es6的数组新方法array.from

```js
 var arr = Array.from(oldarr)
```

4、解构赋值

```js
    function args(){
      console.log(arguments);
      let newArr = [...arguments];
      console.log(newArr);
    }
    args(1,2,3,23,2,42,34);
```



### 如何判断一个数组

1． Instanceof 方法   

​	Arr instanceof Array  返回 true 或false  

2．Array.isArray（） 返回true false

3．使用一下数组的方法，不能使用，则不是数组

4．Array.prototype.isPrototypeOf([])  利用isPrototypeOf()方法，判定Array是不是在obj的原型链中,是返回true，不是返回false

### 数组的方法有哪些

.unshift() 从`数组前面添加数据` 返回值：添加后的数组长度

.shift() 从数组`前面删除一个元素` 返回值:被删除的元素

.push() 从`数组添加数据 返回值`：添加后的数组长度

.pop() 从`后面删除一个元素`	返回值：被删除的元素

.`splice() 删除数组中的元素`` 

删除：两个参数时(x,y)：x表示开始的下标，y表示“移除的个数"

添加，替换：多个参数（x,y,z,...）：x开始的下标，y删除的个数，后面的参数：要添加或替换的数据

.`slice() 截取 返回一个新数组，不改变原数组`

两个参数时：第一个参数x,开始截取下标，第二个参数，结束截取下标，不包括

一个参数：从该下标开始到结尾

没有参数：全部截取，复制

.indexof() 判断这个元素在不在当前的数组，元素存在时返回下标，不存在时返回-1

.findIndex() 查找元素 存在时，返回满足条件的第一个下标，不存在时，返回-1

遍历：.forEach() 

.filter() 用于筛选 满足一定条件的元素，组成新的数组

### 改变原数组的有哪些方法

​	 arr.push()   //从后面添加
 	arr.pop()   //从后面删除一项
  	arr.unshift()  //从前面添加
  	arr.shift()     //从前面删除一项

​	arr.reverse() 翻转数组

​	arr.splice()  删除数组元素，二个参数，或多个参数（增删改）

​	arr.sort 数组排序

### 数组拉平，一维变多维有哪些方法

1、`Arr.flat()` 数组拉平，变成一维的数组，`该方法返回一个新数组，对原数据没有影响`。Flat（）中的参数时一个整数，表示拉平的层数。Infinity关键字表示不论多少层都转为一维数组。如果原数组有空位，flat（）方法会跳过空位。

2、flatMap()方法对原数组的每个成员执行一次函数

3、toString()方法，但这种方法的最终结果的数据类型是`String类型`，要继续进行转换

​	let arr = [1,2,3,[11,12,[22,23]]];

​	Let newArr = [];

​	newArr = arr.toString()

4、定义一个新数组，递归，arr[i].length 判读数组的元素是否有长度，有长度就继续循环将元素推进一个新数组

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8660\wps2.jpg) |

### 数组遍历的方法

`forEach(),map(),every(),filter(),some()`的区别？

1、forEach()用来遍历数组，`没有返回值`。item数组中的每一项，index下标，self数组本身

arr.forEach(function(item,index,self){ })

2、map() `不会改变原数组，创建一个新数组`，新数组中的每个元素都调用一个提供函数的返回结果，新数组是函数的return值，且新数组和原数组长度一样。也是三个参数，用到哪个参数写哪个参数

 			Var newArr = arr.map(function( item,index，self){ return })   可以遍历出与数组一样的数

3、Filter（） `返回一个新数组，新数组中的元素是return 为true时的值`。新数组长度和元素组长度不同，同样有三个参数。主要用于`筛选数组`。

Var newArr = arr.filter(function(){ return ;})

4、some（）返回一个布尔值，用于检测数组中的元素是否满足指定条件，找到满足条件立即停止，返回一个布尔值，`查找到第一个满足条件的true时，终止遍历，停止查找。当找不到时，返回false`，要把整个数组都遍历一遍。三个参数。 `手动return true；可以停止遍历`

如果想用some去取出数组中的一个值

先在外面定义一个变量，当找到这个值时，立刻赋值给这个变量

Var arr = [12,123,45,69];

Var n;

Var res = arr.some(function(item，index)){

If(item == 123){

n = item;

}

Return ture;//找到之后return true停止。

}

5、every（） 返回一个布尔值，数组中的`每一个元素都能通过回调函数的测试则返回true，否则返回false`。一旦返回false，立即终止循环

### Slice和splice的区别 

1.slice(start,end)：方法可从已有数组中返回选定的元素，返回一个新数组，包含从start到end（不包含该元素）的数组元素。
  注意：该方法`不会改变原数组，而是返回一个子数组`，如果想删除数组中的一段元素，应该使用Array.splice()方法。
  2.splice()：该方法向或者从数组中添加或者删除项目，返回被删除的项目。（该方法`会改变原数组`）
  splice（index,howmany,item1,...itemX）..

### split和join的区别

S`plit()方法用于把一个字符串分割成字符串数组`. stringObject.split(a,b)这是它的语法 a是必须的决定个从a这分 

割 b不是必须的，可选。该参数可指定返回的数组的最大长度 。 如果设置了该参数，返回的子串不会多于这个 

参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。 注意返回的数组中不包括a 

本身。 

`Join()方法是将数组转换成字符串`。 

1.join() 方法用于把数组中的所有元素放入一个字符串。 元素是通过指定的 

分隔符进行分隔的。 指定分隔符方法join("#");其中#可以是任意. 

### 数组的乱序



### 字符串的方法

`String查找字符`

​	indexOf() 查找字符在整个字符串的位置下标，不存在时，返回-1

​	lastIndexOf() 从后面查找

​	charAt（下标）查询下标处的字符，返回字符，不存在下标时，返回空

​	charCodeAt（下标）返回下标对应的字符串的ASCII码

`String拼接和截取`

​	join() 在每个元素后面都拼接

​	`split() 截取出来指定字符，不改变原字符串`

​	.concat() 拼接 可以与多个字符串进行拼接 ，不改变原数组

​	substring(x,y) 第一个参数x，截取开始下标，包括在内,第二个参数y，截取结束的下标，不包括在内

​	.substr(x,y) 第一个参数x,开始下标 第二个参数，截取的个数

### 用js如何去除url中的#号

1、单纯将hash路由改变成history路由即可去除hash的#号,此时需要服务器做路由重定向,比如nginx, node重定向

2、单纯去除#

```js
function dropHash(url) {
  let i = url.indexOf('#')
  return i > -1 ? url.replace(/#/g, '') : url
}
```

### 对象

使用`属性`描述事物的`特征`，使用`方法`来描述`功能`

对象是属性和方法的集合体

`创建对象`： 1、构造函数 new  2字面量的方式 var obj={}

`一个属性和一个值叫**键值对`**。多个键值对之间使用逗号分隔，键的方式添加属性

`获取`：1、点属性获取  2、以键的方式访问属性

`遍历：`  for （var key in obj）

### 如何实现sleep的效果

1、while循环

```js
function sleep(ms){
   var start=Date.now(),expire=start+ms;
   while(Date.now()<expire);
   console.log('1111');
   return;
}
```

执行sleep(1000)之后，休眠了1000ms之后输出了1111。上述循环的方式缺点很明显，容易造成死循环。

2、通过promise来实现

```js
function sleep(ms){
  var temple=new Promise(
  (resolve)=>{
  console.log(111);setTimeout(resolve,ms)
  });
  return temple
}
sleep(500).then(function(){
   //console.log(222)
})
//先输出了111，延迟500ms后输出222
```

3、通过async封装

```js
function sleep(ms){
  return new Promise((resolve)=>setTimeout(resolve,ms));
}
async function test(){
  var temple=await sleep(1000);
  console.log(1111)
  return temple
}
test();
//延迟1000ms输出了1111
```

4、通过generate来实现

```js
function* sleep(ms){
   yield new Promise(function(resolve,reject){
             console.log(111);
             setTimeout(resolve,ms);
        })  
}
sleep(500).next().value.then(function(){console.log(2222)})
```

### 如何使用元素js更改css规则

1、通过在javascript代码中的node.style.cssText="css表达式1；css表达式2；css表达式3 "的方式直接更改CSS样式。

2、先在CSS样式表中对特定的类如“active类”设置样式（这里的active类是假定的，暂时不存在），然后再在javascript代码中通过node.classname="active"使得CSS样式表中对active类的样式设置附加到该node节点上来。



## WebAPI

（浏览器平台对外公开的提供操作浏览器个网页的接口（BOM、DOM））

### JavaScript的组成

ECMAscript：变量，数据类型，运算符、分支语句、循环、函数、对象（方法和属性）

Bom：浏览器对象模型	操作浏览器的方法

DOM：文档对象模型 	把整个网页当做一个对象，操作页面元素的方法

文档中最大的对象是document

js中最大的对象是window

文档最大的标签是html

元素的概念在Dom中才存在

### 什么是DOM树

文档树：浏览器在加载html文件时，会把文档、文档中的标签、属性、文本、注释转换成对象，但不会改变直接的关系。然后按照标签的关系（父子、兄弟、祖孙）以`树状结构存储到内存`中。

文档树中的对象也称为节点对象

节点对象：文档（document） 、元素（标签转换的对象）、文本、属性、注释

### 获取页面元素的方法

通过id名获取：document.getElementById('id名')

通过标签名获取：document.getElementByTagName('标签名')   伪数组（不能调用真正数组中内置的方法）

通过选择器来获取：document.querySelector('选择器名')  只能获取单个元素

通过选择器来获取  ：document.querySelectorAll('选择器')  一组伪数组

获取body元素：document.body  

### 什么是事件？

事件：用于与用户交互的动作，本质是：浏览器里面一种 触发-响应 的一种机制

`事件三要素`：

- 事件源:   被触发事件的元素，如 当按钮被操作
- 事件类型:  事件的触发方式，如 鼠标点击 或 键盘输入【onclick，ondblclick】
- 事件处理函数: 事件触发后要执行的代码，如 函数内让 body 变背景色

`给元素注册事件`

​	本质：给对象添加方法

​	语法：事件源.事件类型 = 事件处理程序

​	步骤：1、获取元素	2、给元素注册事件	3、事件处理函数（函数体中的代码，就是事件发生后要执行的程序）

 `事件处理程序中的this指向事件源`

### 事件有哪些

`鼠标事件`

onclick：点击事件
	ondblclick：双击事件
	
	onmouseenter：onmouseleave 不支持冒泡
	
	onmouseover：onmouseout 支持冒泡
	
	onblur：失去焦点
	
	onfocus：获得焦点
`键盘事件` 一般情况给document绑定键盘事件

onkeydown    键盘按下事件

onkeyup         键盘弹起事件

###  mouseover和mouseenter的区别

- mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout
- mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave

### 什么是元素属性

操作元素实质就是改变属性，元素的属性发生变化，元素也会变化

`获取属性`：语法：元素.属性名；

`设置属性`：语法：元素.属性名 = 值；

常见的属性：href、title、id、src、className、innerText 、innerHTML

类名属性的获取和修改需要写成  className

### 自定义属性

自定义属性：`data-`XXX=“ ”

标签自定义属性：`不可以用【元素.属性】`的方式去访问或者去设置

- 元素.getAttribute()           获取属性
- 元素.setAttribute()           设置属性
- 元素.removeAttribute()   移除属性

### 样式属性

修改元素的样式，有两种办法，1、`行内样式`（style），2、`修改类名`（calssName）

`style属性：`元素.style.样式属性 = 值

`className类名：`先把类名定义好，直接修改元素的类名，达到修改样式的效果，但可能会被层叠掉

修改：元素.className = '类名'	清空类名：元素.className = ' '

`classList`：因为className直接操作可能覆盖原先的类名，所有我们如果怕覆盖就用classList

添加：元素.classList.add("类名称")

删除：元素.classList.remove("类名称")

切换：元素.classList.toggle("类名称")

### innerText和innerHTML的区别

`获取：`

通过innerText获取,仅仅包含文本

通过innerHTML获取，若有子标签时，会包含文本和子标签

`设置：`

通过innerText设置,若设置中包含了子标签，该标签不会被渲染而是当做普通文本显示

通过innerHTML设置,若设置中包含了子标签，该标签会被渲染显示

### 节点

元素节点（HTML标签元素），`文本节点`，属性节点

`节点关系：`

父节点：parentNode 返回父元素节点

子节点：children 返回子元素节点【cihldNodes】

第一个元素子节点：firstElementChild  （元素节点只包括html标签元素）

第一个节点：firstChild()

最后一个元素子节点：lastElementChild

最后一个节点：lastChild()

下一个元素兄弟节点：nextElementSibling 只会获取下一个元素节点

下一个兄弟节点：nextChild()

上一个元素兄弟节点：previousElementSibling

上一个兄弟节点：previousSibling()

`节点属性：`

nodeType：节点类型- 节点的nodeType属性的作用：元素→ 1；  文本→3

nodeName：节点名称- 节点的nodeName属性的作用：元素→ 大写的标签名  文本→ #text 

nodeValue：节点值- 节点的nodeValue属性的作用：元素→ null  文本→ 文本的内容

### 怎样添加，移除，移动，复制和创建和查找节点

appendChild() //添加  （元素后面）

removeChild() //移除

replaceChild() //替换

insertBefore() //插入 （元素前面）

 cloneNode()   //复制

`创建新节点`

　　createDocumentFragment() //创建一个DOM片段

　　createElement() //创建一个具体的元素  `执行速度快，性能高` ，在实际开发中**推荐使用** 

​	innerHTML `在追加多个元素时执行速度慢，性能差。不推荐使用`

　　createTextNode() //创建一个文本节点

`查找`

　　getElementsByTagName() //通过标签名称

　　getElementsByName() //通过元素的Name属性的值

　　getElementById() //通过元素Id，唯一性

### 排他思想

点击哪一个哪一个改变样式，其他的都不变。这是首先将所有元素都清空样式，然后点击哪一个哪一个添加样式

### 事件监听

`事件监听注册事件`：事件源.`addEventListener`('事件类型',事件处理程序,是否捕获);

1. 事件源 → 操作的元素
2. 事件类型→ 在此不加on,  onclick→click
3. 事件处理程序→ 函数
4. 是否捕获，可选参数，默认为false。 true→ 捕获，false→冒泡

`事件监听移除事件`：元素.removeEventListener('事件类型'，事件处理程序名称)

​	1、事件源，操作的元素

​	2、事件类型，不加on

​	3、事件处理程序的名字：函数名

​	注意：若将来要通过事件监听的方式移除事件时，之前注册事件**要把事件处理程序单独抽取出来命名** 。

## BOM(浏览器对象模型)

### 定时器

`一次性定时器`window.setTimeout(callback, time)

仅仅执行一次

callback，函数定义，函数体中存放定义器要执行的代码。

time,等待的时间，数字，表示的是毫秒

`反复性定时器`window.setInterval(callback, time)

重复执行

### location对象

将来操作浏览器的地址栏

`属性`：location.href  设置或获取地址栏地址

`方法：`

- location.reload(); 刷新页面
- location.assign()：会产生历史记录
- location.replace()：不会产生历史记录

### onload事件

页面加载完成之后，执行的事件

onload事件是页面加载事件，一般绑定给window

### offset系列属性

offset获取的是CSS文件中的属性

`获取元素的大小`：

​	元素.offsetwidth、元素.offsetHeight

​	返回数字 ：padding+内容+border

​	不能设置，只能读取

`获取元素位置`：

​	元素.offsetLeft、元素.offsetTop

​	返回值：参照物是谁返回谁，如果没有定位是body的位置

`获取父元素位置`

​	元素.offsetParent:获取的是定位的父元素

​	元素.parentNode:获取的是标签父元素

### touch事件

- touchstart，手指按下事件
- touchmove，手指移动事件
- touchend，手指松开事件

`touch事件对象`

1. 事件对象.touches ：位于屏幕上的所有手指的列表；伪数组
2. 事件对象.targetTouches ：位于该元素上的所有手指的列表； 
3. 事件对象.changedTouches：被改变的手指列表。  touchstart时包含刚与触摸屏接触的触点，touchend时包含离开触摸屏的触点

touches和targetTouches必须是在屏幕上，而changedTouches可以获取离开屏幕的手指的

`手指的位置`

1. 手指对象.clientX/Y 手指相对于可视区域
2. 手指对象.pageX/Y 手指相对于文档

### Zepto

Zepto**是一个轻量级的 **针对现代手机端浏览器的 JavaScript 库

使用 zepto 步骤

1. 引入 `zepto.js` 核心库。

2. 引入 `zepto.touch.js` 移动端手势模块。

3. 新建 `<script>` 标签写业务代码。

   

### 本地存储技术

localSortage对象：把数据以字符串的方式保存本地

获取： localStorage.getItem()
​设置： localStorage.setItem()

### json方法补充

作用：把字符串数组转成数组，或者把数组转成字符串数组

例如：var str = '["a","b","c"]';

​	JSON 解析：JSON.parse()：返回转换后的数组

​	JSON 转字符串：JSON.stringify()

## JQuery

### window onload和$(function)的区别

window onload = function()是在页面所有元素都加载完成之后在执行，多个定义的话只执行最后一个

$(function)是在dom元素加载完之后就执行，内容不一定已经全部加载，多个定义的话则依次执行

### 取数组的最大值

// es5
Math.max.apply(null, arr);
// es6
Math.max(...arr);

## js高级

### 对面向对象的理解

将事务分解成为一个对象。然后由对象之间分工与合作

三大特性：封装性，继承性，多态性

### 谈谈对构造函数的理解

构造函数是一种`特殊的函数`，主要`用来初始化对象`，即为对象成员变量赋初始值，它总与new一起使用。可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面

- 静态成员：在构造函数本上添加的成员称为静态成员，只能由构造函数本身来访问
- 实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问

**在JS 中，使用构造函数时要注意以下两点：**

1.构造函数用于创建某一类对象，其首字母要大写

2.构造函数要和new 一起使用才有意义

### new在执行时会做的四件事情

1、让内容中创建一个新的空对象

2、让this指向这个新的对象

3、执行构造函数里面的代码，给这个新对象添加属性和方法

4、返回这个新对象



### 高阶函数

函数作为参数或返回值输出

函数也是一种数据类型，同样也可以作为参数，传递给另外一个参数使用。最典型的就是作为回调函数。



### 谈谈你对闭包的理解

一个函数访问另外一个函数内部的局部变量

`作用：`延伸变量的作用范围

```js
<script>
	function fn1(){
		// fn1 就是闭包函数
		var num = 10;
		function fn2(){
			console.log(num); // 10
		}
		fn2()
	}
	fn1();
</script>

```

`缺点：`会造成内存泄漏、全局污染

### 垃圾回收机制

因为内存泄漏从而处出现了垃圾回收机制

内存泄漏：`指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束`

哪些操作造成内存泄漏：

​	1、`全局变量`引起的内存泄漏

​	2、没有清理的Dom元素引用

​	3、被遗忘的定时器或者回调

​	2、`闭包引起的内存泄漏`

```js
function bindEvent(){
var obj=document.createElement("XXX");
obj.onclick=function(){
//Even if it's a empty function

处理方法：
	将事件处理函数定义在外部，解除闭包,
       //将事件处理函数定义在外部
function onclickHandler(){
//do something
}
function bindEvent(){
var obj=document.createElement("XXX");
obj.onclick=onclickHandler;
}
   定义事件处理函数的外部函数中，删除对dom的引用。
   function bindEvent(){
var obj=document.createElement("XXX");
obj.onclick=function(){
//Even if it's a empty function
}
obj=null;
}
```

垃圾回收：

1、JS的回收机制 

`找出不再使用的变量，然后释放掉其占用的内存`，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收系统（GC）会按照固定的时间间隔,周期性的执行。 

垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。用于标记的无用变量 的策略可能因实现而有所区别，通常情况下有两种实现方式：`标记清除和引用计数`。引用计数不太常用，标记清除较为常用。 

2、标记清除 

js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记 为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能 会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

3、引用计数 

引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值（function object array） 赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果 包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。 

### 怎样避免内存泄漏

1）`减少不必要的全局变量`，或者生命周期较长的对象，及时对无用的数据进行垃圾回收； 

2）注意程序逻辑，`避免“死循环`”之类的 ； 

3）避免创建过多的对象 原则：不用了的东西要及时归还。 

### 继承的几种方式？

`ES6中` extend super

`ES5中` 组合继承又分为属性继承和方法继承

`属性继承：`使用call() 改变其this指向，call把父类的this指向子类

`方法继承`：把父类的实例对象保存给子类的原型对象

①将子类所共享的方法提取出来，让子类的prototype 原型对象= new 父类()

②本质：子类原型对象等于是实例化父类，因为`父类实例化之后另外开辟空间，就不会影响原来父类原型对象`  

③一定要让Son指回构造函数

```js
Son.prototype = new Father();

Son.prototype.constructor = Son;
```

**`用构造函数实现属性继承，用原型对象实现方法继承`**

### 函数的调用的方法

1. 普通函数【fn()】
2. 对象的方法【对象.方法()】
3. 构造函数【new Fn()】
4. 绑定事件函数【obj.onclick = function () {}】
5. 定时器函数【window.setInterval(function () {},1000)】
6. 立即执行函数【(function () {})()】



### this的指向

构造函数的this指向实例对象 ，原型对象里面的方法也指向实例对象

对象方法调用this指向该方法所属对象（谁调用this是谁）

事件绑定方法this指向绑定的事件对象

定时器，自调用函数，普通函数 指向window 

`this 永远指向调用它的对象，new的时候，指向new出来的对象`。

`箭头函数没有自己的 this，当在内部使用了 this时，它会指向最近一层作用域内的 this`  需要闭包时使用箭头函数就很方便

### 箭头函数有哪些不同

1、不能作为构造函数，不能使用new
  2、不能使用argumetns,取而代之用…(解构)

```js
    function A(a){
      console.log(arguments);
    }
    A(1,2,3,4,5,8);  //  [1, 2, 3, 4, 5, 8, callee: ƒ, Symbol(Symbol.iterator): ƒ]

    let B = (b)=>{
      console.log(arguments);
    }
    B(2,92,32,32);   // Uncaught ReferenceError: arguments is not defined


    let C = (...c) => {
      console.log(c);
    }
    C(3,82,32,11323);  // [3, 82, 32, 11323]
```



  3、不绑定this，会捕获其所在的上下文的this值。箭头函数的this永远指向上下文的this，call、apply、bind也无法改变
  4、箭头函数没有原型对象

### 改变this指向的方法

`call() apply() bind()` 

相同点:  都可以改变函数内部的this指向.

区别点:  

1.call 和apply  会调用函数, 并且改变函数内部this指向.
2.call 和apply 传递的参数不一样, call 传递参数aru1, aru2..形式apply 必须数组形式[arg]
3.bind  不会调用函数, 可以改变函数内部this指向

主要应用场景:  
1.call 经常做继承. 
2.apply 经常跟数组有关系.比如借助于数学对象`实现数组`最大值最小值

```js
var arr = [23,45,56,23,54];

var n = Math.max.apply(null,arr);

console.log(n);[]
```

3.bind  不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向

### 创建对象的方法？

1、对象字面量

2、new Object()【构造函数】构造函数要和new 一起使用才有意义

3、自定义构造函数



### 原型链

`原型对象prototype`，是一个对象（对象的所有属性和方法，都会被构造函数所拥有），也是`构造函数的一个属性`，每个构造函数都有prototype属性。

作用：为了`共享方法，从而达到节省内存`

`对象原型：__proto__`就是一个属性，是对象的一个属性，这个属性用来指向原型对象。`只读`

作用:指向prototype。

意义：为对象的查找机制提供一个方向，一条路线，它是一个非标准属性，因此在实际开发中，不可以使用这个属性，它`只是内部指向原型对象`。

`构造函数constructor`，原型对象的一个属性，原型（proto）和构造函数（prototype）原型对象里面都有一个属性constructor

作用：指回构造函数本身

### 对象合并、拼接

`1、Object.assign`方法用于`对象的合并`，将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign(target, sources);

Object.assign({},obj1,obj2)  第一个参数target是`防止相同属性名，后者会覆盖前者`

2、、jquery 有提供一个$.extend也可以实现

$.extend({},obj1,obj2); 第一个参数target有相同的作用

### 浅拷贝和深拷贝

浅拷贝 ------  只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。

深拷贝 -------  在计算机中`开辟了一块新的内存地址用于存放复制的对象`

实质：深拷贝拷贝的是堆,浅拷贝拷贝的是栈 。只有复杂数据类型才有深拷贝  复杂数据数据存在堆上，在栈上面只留下一个地址（指针）

`浅拷贝`（只拷贝最外层）：浅拷贝就是对内存地址的复制，让目标对象指针和源对象指向同一片内存空间，当内存销毁的时候，指向这片内存的几个指针需要重新定义才可以使用，要不然会成为野指针。

`Object.assign`方法用于`对象的合并`，将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign(target, sources);

Object.assign({},obj1,obj2)  第一个参数target是防止相同属性名，后者会覆盖前者

```js
var obj = {
			name : '张三丰',
			age : 22
		};

		var newObj = {};
		for (key in obj) {
			newObj[key] = obj[key];
		}

		console.log(newObj);
```



`深拷贝`：深拷贝是指拷贝对象的具体内容，而内存地址是自主分配的，拷贝结束之后，两个对象虽然存的值是相同的，但是内存地址不一样，两个对象也互不影响，互不干涉。
深拷贝的方法：1、递归拷贝
                2、使用Object.create()方法
                3、jquery 有提供一个$.extend也可以实现
                4、函数库lodash，也有提供`cloneDeep`用来实现

递归拷贝：

``` js
var obj = {
			name : '1张三丰',
			age : 22,
			messige : {
				sex : '男',
				score : 16
			},
			color : ['red','purple','qing']

		}

		var newObj = {};


		function kaobei (newObj,obj) {

			for (key in obj) {

				if (obj[key] instanceof Array) {
					newObj[key] = [];
					kaobei(newObj[key],obj[key]);
				} else if (obj[key] instanceof Object) {
					newObj[key] = {};
					kaobei(newObj[key],obj[key])
				} else {
					newObj[key] = obj[key];
				}

			}

		}
		obj.messige.sex = 99;
		kaobei(newObj,obj);
		console.log(newObj);
```



### 预解析

预解析会把初始化var，function声明的变量、函数，全部提升到当前作用域的最顶端。

“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。`而变量的赋值和函数的调用还在原来的位置。`

### 什么是函数声明？什么是变量声明提升

  通过function关键字定义的函数和var关键字定义的变量在预解析时会被提升到当前作用域的最顶端.

### 函数节流和函数防抖

​	相同点：

​           一个高频触发的函数，规定的时间内，函数防抖和函数节流都是用来对`函数的调用做降频`（降低单位时间内被调用的次数）处理的。

​	不同点：

​           函数防抖是`执行最后一次事件`，时间是累加的

​	   应用场景：

​             1、频繁点赞和取消点赞，只读取最后一次的操作

​             2、搜索内容时，用户在不断的输入值时，用防抖来节约请求资源。

​           函数节流是执行`最先触发的事件`，后面的不执行。规定时间是指，每一个规定时间最开始时，触发一次事件

​	    使用场景：

​                     1、onscroll（屏幕滚动触发滚动事件），

​                     2、onresize（窗口大小调整事件）

## ES6

### ES6的新特性

作用域、函数扩展（扩展运算符、默认参数、箭头函数）、异步promise、模块化。

###  let和const的区别？

   let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。
   const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能直接修改。
   因为对象是引用类型的，这就意味着`，const仅保证指针不发生改变，修改对象的属性不会改变对象的指针`，所以是被允许的。
  也就是说const定义的`引用类型只要指针不发生改变，其他的不论如何改变都是允许的`。

### let,const与var的区别

- 不能重复定义

- 没有变量提升（var定义的变量是有变量提升的），必须`先定义再使用`

- 全局变量不会附加到window对象的属性中

- 具有块级作用域

  ```js
  for (var i = 1; i <= 5; i++) {
            setTimeout(() => {
                console.log(i); 
            }, 1000); 
        }
  6 6 6 6 6 
  //var 是在全局范围内有效可以声明多个,i都是一样的
  for (let i = 1; i <=5; i++) {
      setTimeout(() => {
          console.log(i)
      }, 1000);
  }
  1 2 3 4 5
  //let 只能声明一次，每次循环的i其实都是一个新的变量，所以 setTimeout 定时器里面的i其实是不同的变量
  ```


### const常量有什么作用？确定不能修改吗？修改之后会报错吗？你有没有试过？ ？？

   `const`实际上保证的，并不是常量的值不得改动，而是`常量指向的那个内存-地址所存的数据不得改动`。

- 对于简单类型的数据（数值、字符串、布尔值），它的值直接保存在栈区。就保存在常量名指向的那个内存地址中，因此等同于常量值。
- 对于复合类型的数据（如对象和数组），常量指向的内存地址，保存的只是一个指向实际数据的指针，`const`只能保证这个指针是固定的（即总是指向一个固定的地址），至于它指向的数据结构是不是可变的，就不能控制了。因此，`将一个对象声明为常量必须非常小心,它的属性是可以修改的`。

如果是值类型，值不可变

   如果是引用类型，地址不可变
   不能修改引用类型的指向，但是可以修改引用类型里的属性值。

### commonJs和AMD模块，ES6模块的区别



### Map和Set的区别

Set：　
　　    （1）成员不能重复
　　    （2）只有键值没有键名，类似数组
　　    （3）可以遍历，方法有add, delete,has
Map:
　　    （1）本质上是健值对的集合，类似集合
　　    （2）可以遍历，可以跟各种数据格式转换

		Set 对象类似于数组，且成员的值都是唯一的。

​	Map 对象是键值对集合，和 JSON 对象类似，但是 key 不仅可以是字符串还可以是对象

`<https://www.cnblogs.com/dreamcc/p/10892918.html>`

### Promise是什么，解决了什么，之前怎么实现的

`promise构造函数是同步执行的，then方法是异步执行的`

一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，`Promise 是一个对象，从它可以获取异步操作的消息`。Promise 提供统一的 API，`各种异步操作都可以用同样的方法进行处理`。

`解决的问题`Promise对象，就可以将`异步操作以同步操作的流程`表达出来，避免了层层嵌套的回调函数。此外，`Promise`对象提供统一的接口，使得控制异步操作更加容易

`Promise`对象有以下两个特点：

（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。

（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。



Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。

`then`方法是定义在原型对象`Promise.prototype`上的。它的作用是为 `Promise 实例添加状态改变时的回调函数`。前面说过，`then`方法的第一个参数是`resolved`状态的回调函数，第二个参数（可选）是`rejected`状态的回调函数。

`catch`用于指定发生错误时的回调函数。`then`方法指定的回调函数，如果运行中抛出错误，也会被`catch`方法捕获。

`all`方法提供了`并行执行异步操作的能力`，并且在所有异步操作执行完后才执行回调。`Promise.all()`方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。就可以`并行执行多个异步操作，并且在一个回调中处理所有的返回数据`

### Promise 中reject 和 catch 处理上有什么区别

reject 是用来抛出异常，catch 是用来处理异常
reject 是 Promise 的方法，而 catch 是 Promise 实例的方法
reject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch

### promise中的catch和trycatch中catch有什么区别？

promise中的catch可以捕获异步的异常，promise中的异常只能通过.catch 来捕获

try/catch中的catch只能捕获同步的异常，所以在项目中try里写了await，异步写成同步。

### 如何解决异步回调地狱

promise、generator、async/await

### 同步和异步的区别

同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为
异步方法调用一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而异步方法通常会在另外一个线程中，整个过程，不会阻碍调用者的工作

### js为什么需要异步

单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。
如果JS中不存在异步,只能自上而下执行,如果上一行解析时间很长,那么下面的代码就会被阻塞。对于用户而言,阻塞就意味着"卡死",这样就导致了很差的用户体验

### EvenLoop，执行栈和任务队列、宏任务和微任务

​	JavaScript 的运行机制，它是单线程的。JavaScript 中的任务可分为同步任务和异步任务，同步任务总是先进入执行栈中执行，异步任务会被挂起，直到有结果返回时，异步任务会进入任务队列中等待主线程读取执行。当执行栈为空时，主线程便会循环往复地读取任务队列中的事件，进入执行栈执行，这个过程叫 Event Loop。主线程对任务队列的读取也有先后之分，首先会读取宏任务，最开始是 script 整体代码，执行完一个宏任务后，会去查找微任务，`将微任务队列的事件都执行完`，这个过程也是循环往复的。

​	JavaScript 在运行时会将变量存放在堆（heap）和栈（stack）中，堆中通常存放着一些对象，而变量及对象的指针则存放在栈中。

## ajax

### ajax和axios、fetch的区别

axios是通过promise实现对ajax技术的一种封装，就像jQuery实现ajax封装一样。简单来说： ajax技术实现了网页的局部数据刷新，axios实现了对ajax的封装。

 `ajax`

- 本身是针对MVC的编程,不符合现在前端MVVM的浪潮

- 基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案

- JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）

  `axios`

  axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端

- 从 node.js 创建 http 请求

- 支持 Promise API

- 客户端支持防止CSRF

- **提供了一些并发请求的接口**（重要，方便了很多的操作）

- 拦截请求和响应

- 转换请求和响应数据

- 取消请求

- 自动转换JSON数据

  `fetch`

  符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里
  更好更方便的写法
  更加底层，提供的API丰富（request, response）
  脱离了XHR，是ES规范里新的实现方式
  1）fetchtch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理
  2）fetch默认不会带cookie，需要添加配置项
  3）fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费
  4）fetch没有办法原生监测请求的进度，而XHR可以

### axios是什么

axios](https://www.kancloud.cn/yunye/axios/234845) :**`不是vue的插件`**，可以在任何地方使用

 既可以在`浏览器端`又可以在**`node.js`**中使用的发送http请求的库，支持**`Promise链式调用`**，不支持jsonp
中文是异步的javascript和XML
AJAX并不是一种新技术，而是一种成熟的解决方案。它要解决的问题是在网页的局部更新。
A:异步的
X:xml
浏览器通过内置对象 XMLHttpRequest 向服务器发起请求，并可以接收服务器返回给浏览器的数据，这一过程或实现这一过程的技术就是我们所说的 Ajax

### ajax的优缺点，及原生实现？

**优点**：

1. 局部刷新

2. 异步与服务器通信，不打断用户的操作

3. 将一些后端的工作移到前端，减少服务器与宽带的负担

4. Ajax使得页面与应用分离，也就是数据与呈现相互分离

**缺点：**

1．Ajax不支持浏览器的返回按钮

2．Ajax暴露了与服务器交互的细节，安全问题

3．对搜索引擎的支持比较弱

4．不容易调试

**原生ajax**

1. new 一个xhr对象

​     Var xhr = new XMLHttpRequest();

2. 设置请求

   Xhr.open（请求的方式，请求的url地址）

3. 设置回调函数

   Xhr.onload=function(){

      }

4. 发送请求

   Xhr.send();

**如果get请求需要带参数，就附加在请求地址url后面，post请求写在send方法中，同时post设置请求头，在回调函数的前面设置。****

xhr.setRequestHeader(‘content-type’,’application/x-www-from-urlencoded’)，在jQuery中的$.ajax()，已经给我们设置了内置的请求头不用设置了。** 

### 同源策略是什么

同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
指一段脚本只能读取来自同一来源的窗口和文档的属性。

### 跨域是什么原因引起？怎么解决？

跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。不在同源下，同源:协议、域名、端口号都相同。

`① jsonp函数`

- JSONP：非正式传输协议。
- 发现凡是拥有`”src”这个属性的标签都拥有跨域的能力`，比如`<script>、<img>、<iframe>`;
- 就是本地写好回调函数，动态生成一个script标签，写入src的路径把函数名传过去，说到底回来的脚本，里面执行的代码就是执行这个函数。相当于是异步加载JS，异步执行我们已经写好的回调函数。
- ajax和jsonp其实本质上是不同的东西。`ajax的核心是通过XmlHttpRequest获取非本页内容`，而`jsonp的核心则是动态添加script标签来调用服务器提供的js脚本。`

在HTML DOM中,script标签本身就可以访问其它域的资源，不受浏览器同源策略的限制，可以通过在页面动态创建script标签。

```js
var script = document.createElement('script'); 
script.src = "http://aa.xx.com/js/*.js"; document.body.appendChild(script);
```

`② iframe实现跨域`

基于iframe实现的跨域要求两个域具有aa.xx.com,bb.xx.com这种特点，也就是两个页面必须属于同一个顶级基础域（例如都是xxx.com，或是xxx.com.cn），使用同一协议（例如都是 http）和同一端口（例如都是80），这样在两个页面中同时添加`document.domain，就可以实现父页面调用子页面的函数`二级域名下可以共享数据

`③ 跨域资源共享（CORS）`

服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。

通信标准。可理解为支持跨域通信的AJAX。浏览器在识别发送一个跨域请求时，会在头部加一个origin，支持跨域通信。

`④ 使用HTML5的window.postMessage方法跨域`
window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。

```js
【A页面】
window.postMessage(data,"http://B.html");

【B页面】
window.addEventListener("message",function(ev){
  ev.origin // http://A.html
  ev.source // A页面的window
  ev.data. 
},false);
```

`⑤nginx反向代理`

```js
server {
  server_name www.test.com
  listen 80;
 
  location / {
    proxy_pass http://127.0.0.1:8080;
  }
}

```

webSocket:使用Socket.io,它很好的封装了webSocket接口，提供了更简单灵活的接口。

### ajax请求的时候get 和post方式的区别

get放在url后面，post 一个放在虚拟载体里面;有大小限制;安全问题;

Get 请求能缓存，Post 不能
Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样
Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术
URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
Post 支持更多的编码类型且不对数据类型限制

### ajax/xml/json等网络通信技术和数据交换格式

ajax即异步的JavaScript和XML

ajax有三种数据交换格式

html：xmlHttpRequest -》responseText

xml: 存在responseXml

json:存在responseText中 json的属性名必须使用双引号括起来，独立于语言的文本格式

## Vue

### data（）{}为什么是函数

数据之间不会相互影响

如果data是一个函数的话，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。

### vue中asset与static的区别

相同点：assets和static都是用来存放静态资源的。

不同点：assets 中的文件会经过 webpack 打包，重新编译

static/ 目录下的文件并不会被Webpack处理：它们会直接被复制到最终的打包目录（默认是dist/static）下，且必须使用绝对路径来引用这些文件。

### vue2.0和vue3.0的区别

1、默认进行懒观察（lazy observation）。
	在 2.x 版本里，不过数据多大，都会在一开始就为其创建观察者。当数据很大时，这可能会在页面载入时造成明显的性能压力。3.x 版本，只会对「被用于渲染初始可见部分的数据」创建观察者，而且 3.x 的观察者更高效。
2、更精准的变更通知。
	2.x 版本中，你使用 Vue.set 来给对象新增一个属性时，这个对象的所有 watcher 都会重新运行；3.x 版本中，只有依赖那个属性的 watcher 才会重新运行。
3、3.0 新加入了 TypeScript 以及 PWA 的支持
4、部分命令发生了变化：
	下载安装 npm install -g vue@cli
	删除了vue list
	创建项目 vue create
	启动项目 npm run serve
5、默认项目目录结构也发生了变化：
	移除了配置文件目录，config 和 build 文件夹
	移除了 static 文件夹，新增 public 文件夹，并且 index.html 移动到 public 中
	在 src 文件夹中新增了 views 文件夹，用于分类 视图组件 和 公共组件

### vue3.0在实现数据双向绑定上的优化

vue3.0的数据绑定时基于es6中的Proxy。Proxy 可以理解成，`在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写`

**1. 为什么要替换Object.defineProperty**

替换不是因为不好，是因为有更好的方法使用效率更高

Object.defineProperty的缺点：

> 1. 在Vue中，`Object.defineProperty`无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应

2. Object.defineProperty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。

   Vue里，是通过递归以及遍历data对象来实现对数据的监控的，

如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象，不管是对操作性还是性能都会有一个很大的提升。

而要取代它的Proxy有以下两个优点：

> 1. `可以劫持整个对象，并返回一个新对象`
>    2. `有13种劫持操作`

```javascript
var proxy = new Proxy(target, handler);
参数：

target: 是用Proxy包装的被代理对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。
handler: 是一个对象，其声明了代理target 的一些操作，其属性是当执行一个操作时定义代理的行为的函数。

p是Proxy对象，当其他操作对p进行更改的时候，会执行handler对象的方法。Proxy有13种数据劫持的操作，常用的handler处理方法：

get: 读取值，
set: 获取值，
has: 判断对象是否拥有该属性，
construct: 构造函数
```

### 框架封装的意图

​	事件循环event Loop

### 生命周期

![img](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml4684\wps1.jpg)

其中还有两个特定的在keep-alive中actived、deatived

### 什么是vue生命周期

Vue 实例`从创建到销毁`的过程，就是生命周期。**从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。**

### vue生命周期的作用是什么

它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。

### vue生命周期总共有几个阶段

它可以总共分为8个阶段：创建前/后、载入前/后、更新前/后、销毁前/销毁后。

### 第一次加载页面会触发哪几个钩子

beforeCreate、created、beforeMount、mounted 

### Dom渲染在哪个周期中就已经完成了

DOM 渲染在 mounted 中就已经完成了

### 谈一谈vue的虚拟DOM是什么回事

减少操作真实Dom性能开销比较大，数据驱动视图的时候数据会不断的变化，这是如果是真实dom也要不断的变化

而虚拟dom则不是。数据操控视图，双向数据绑定，例如重复相同的事件，

### Vue的事件修饰符

​	查看官方文档，不同指令的修饰符也有所不同

​	.stop 阻止冒泡

​	.prevent 阻止默认行为。a连接的跳转 调用 `event.preventDefault()`。

​	.self 自身触发的事件只有点击当前事件才会触发事件

​	.once 只触发一次事件处理函数

###  v-show  和v-if的区别

相同点：v-show和v-if都能控制元素的显示和隐藏。

不同点：

​	v-show是通过css样式来控制显隐，编译时都会编译，初始值为false，只是将display设为none，但它也编译了。只编译一次，后面其实就是控制css。如果需要非常频繁地切换，则使用 `v-show` 较好。

​	`v-if` ：对元素进行销毁和重建。初始值为false，就不会编译了。不停的销毁和创建。在运行时条件不太可能改变，则使用 `v-if` 较好。

### v-for和v-if的优先级

v-for的优先级大于v-if

### v-for循环数组或对象时有什么不同

循环数组是有两个参数（item，index） in items  item当前项，index下标

循环对象（value，key，index）in items  value对象的属性值  key属性 index下标

### v-for中的key的实现原理（diff算法）

`key的作用就是给虚拟dom一个唯一的值，以便它能跟踪每个节点的身份，当数据改变的时候高效的更新虚拟DOM`，另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果

深度优先，同层比较，tree diff，component Diff是数据层面的差异比较，element Diff真实Dom渲染，结构差异的比较。

### v-text和插值表达式的区别

​	v-text  更新**`整个`**标签中的内容

​	插值表达式: 更新标签中局部的内容

### v-text和v-html区别

很像innerText和innerHTML

v-text:更新标签中的内容

v-html:更新标签中的内容/标签

注意:尽量避免使用，容易造成危险

### v-bind绑定属性

- 作用:绑定标签上的任何属性

- 场景: 当标签上的属性是变量/动态/需要改变的 

- 语法:  <p :属性="数据对象中的属性名"></p>

  `绑定class对象的语法`： :class="{ class名称": 布尔值 }"

  `绑定class数组的语法`:class="[class变量1,class变量2..]"

  `绑定style对象的语法`：:style="{css属性名: 变量}"

  `绑定style数组的书法`： :style="[对象1,对象2...]"

### v-model是怎么实现的

v-bind： =》： 绑定属性 value属性

v-on ：=》 @ 绑定事件  input事件	 默认第一个参数为event事件参数

从而实现v-model

### v-cloak和v-once

`v-cloak 解决页面初次渲染时 页面模板闪屏现象`

v-cloak写在标签上，然后添加样式属性[v-cloak]{dispaly:none;}

`v-once`使得所在元素只渲染一次 ,千万不能作用在 顶级的div上 => <div id="app"></div>

### vue中常用的API

vue.filter 过滤器

vue.component  注册组件

vue.use  安装 Vue.js 插件。如果插件是一个对象，必须提供 `install` 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。

vue.nextTick()  dom更新后马上操作，需要使用随数据改变而改变的dom结构时

vue.set

### $set添加动态属性了解一下

vue.set

**`如果在实例创建之后添加新的属性到实例上，它不会触发视图更新`**。

由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。

Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用 `Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上`：

Vue.set(vm.obj, 'e', 0)
您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名：

this.$set(this.obj,'e',02)



### 过滤器

就是一个函数 => 有**`返回值`**的函数 => 改变显示数据格式的函数 => 使用场景：日期 /货币/大小写

1. filter('该过滤器的名字',(要过滤的数据)=>{return 对数据的处理结果});
2. 在视图中通过{{数据 | 过滤器的名字}}
3. 过滤器可以传递参数,**`第一个参数永远是前面传递过来的过滤值`** 参数永远从第二个开始

### 计算属性computed  具体怎么用

1.计算属性的值 依赖 数据对象中的值  数据对象发生改变 => 计算属性发生改变=> 视图改变

2.计算属性**`必须有返回值`** 相当于对插值表达式**`逻辑的一次封装`**

3.由于要求立刻return,所以不能有异步请求

4.定义计算属性时，不能与data中的数据重名，不能与methods中的方法重名（Vue实例代理了 Data中所有的属性,methods方法,代理了计算属性中所有的计算属性）

### 计算属性和方法的区别

`方法` 每次都会执行

`计算属性：`有智能跟新模式，执行完一次，会将`执行结果缓存`，如果计算属性依赖的数据没有发生过变化，那么计算属性永远从缓存中取，如果发生变化，重新计算并缓存

- 计算属性不需要调用形式的写法  而methods方法必须采用 方法() 调用的形式
- 计算属性依赖data中的数据变化,如果data并没有发生变化,则计算属性则会取缓存的结果,
- methods不论data变化与否都会重新调用

### 问computed和watch的区别   分别具体怎么用

Vue实例 data/methods/computed 不可重名=> 但是**`watch 一定要重名`**

- 计算属性 必须要有返回值 所以说不能写异步请求 因为有人用它的返回值(插值表达式)

- watch选项中可以写很多逻辑 不需要返回值 因为没有人用它的返回值

- watch是**检测一个数据的变化**，执行watch中的函数

- 当需要根据数据变化 进行相应业务操作,且该操作是**`异步操作`**时,计算属性不能再使用,可以使用监听watch特性

  **`监控谁就写谁的名字`** key(监控名称):value(函数 => 当name值发生改变时就会执行)。函数有两个参数 newValue(新值) oldValue(旧值)

`共同点是`：都是希望在依赖数据发生改变的时候，被依赖的数据根据预先定义好的函数，发生“自动”的变化。

`不同的地方`：

watch和computed各自处理的数据关系场景不同                                                                              

(1).**watch**擅长处理的场景：**一个数据影响多个数据**

(2).**computed**擅长处理的场景：**一个数据受多个数据影响**。总价受到单价和数量的影响

### vue数据双向绑定原理

VUE实现双向数据绑定的原理就是利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。

1、属性监听:把data上的所有属性进行获取值的监听，值变化时通知所有订阅者进行更新数据

2、模板解析：解析的过程就是把和属性相关的所有的Dom订阅者收集，为便属性监听时可以进行订阅者更新

​			所有指令相关的Dom进行我们设置事件的绑定

3、vue是采用`数据劫持结合发布者-订阅者模式`的方式，通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调

```js
var Book = {}
var name = '';
Object.defineProperty(Book, 'name', {
  set: function (value) {
    name = value;
    console.log('你取了一个书名叫做' + value);
  },
  get: function () {
    return '《' + name + '》'
  }
})
 
Book.name = 'vue权威指南';  // 你取了一个书名叫做vue权威指南
console.log(Book.name);  
```

get就是在读取name属性这个值触发的函数，set就是在设置name属性这个值触发的函数



### Vue通信组件间怎样进行通信？或者说都有哪些通信方式

第一种（父子关系）：props（父传子）和$emit（子传父）

`父传子`：嵌套关系，子组件定义自定义属性，子组件中使用props接收父组件传递的数据（`只能用，不能改`）

`子传父`：子组件中使用$emit自定义一个事件，触发一个自定义事件，携带参数，传递数据。父组件监听子组件事件

非父子

第二种：中央事件总线 EventBus（vue实例数据的共享）

```js
eventBus.js
export default new Vue();
```

在需要通信的两端：

​	使用$on订阅

```js
// 没有参数
bus.$on("自定义事件名称", () => {
  // 执行操作
});

// 有参数
bus.$on("自定义事件名称", data => {
  // 执行操作
});
```

使用$emit发布：

```js
// 没有自定义传参
bus.$emit("自定义事件名称");

// 有自定义传参
bus.$emit("自定义事件名称", 数据);
```

第三种：vuex（状态管理器）

### vuex

集中式的方式存储共享数据

作用：进行`状态管理`，`解决复杂组件通信，数据共享`

使用场景：多个视图依赖于同一状态（项目比较大）

​		 `来自不同视图的行为需要变更同一状态`

```js

state：相当于组件中的data，用来`存储共享数据，容器中的数据是共享的，任何组件都可以访问,数据也是响应式的`，数据改变也会驱动视图更新.
组件模板中通过$store访问容器数据，<p>{{ $store.state.count }}</p>
组件js中访问要加this，
methods: {
  onClick () {
    console.log(this.$store.state.count)
  }
}
如在组件中多次使用到容器数据，可以将其封装到计算属性中
computed: {
  count () {
    return this.$store.state.count
  }
}
然后像访问自己的数据一样访问 <p>{{ count }}</p>  

```
mutation：`更改 Vuex 的 store 中的状态的唯一方法是提交 mutation`，类似于事件。每个 mutation 都有一个字符串的 `事件类型 (type)` 和 `一个 回调函数 (handler)`。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数。

在组件中使用commit调用mutation， 

​	`修改容器的state必须使用mutation函数`，可以自定义参数，传递多个参数就放到一个对象中，`不要在mutation中执行异步操作修改state`（调试工具会出问题）

action: `action 提交的是 mutation`，而不是直接变更状态。`异步操作写到action中，也不要在action中直接修改state，而是通过提交mutation来修改state`
getter: 相当于Vue中的computed计算属性

![1582900104802](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1582900104802.png)

### vuex和全局对象主要有两大区别

1、Vuex 的`状态存储是响应式`的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。

2、vuex`专做状态管理`，由一个统一的方法去修改数据，全局变量是可以任意修改的。vuex可以追踪变量的改变,而且必须通过固定的属性才能修改。=》不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。

3、全局变量多了会造成命名污染，vuex不会，同时解决了父组件与孙组件，以及兄弟组件之间通信的问题

### vue.use()和vue.prototype的区别？？？

不是用vue写的插件(插件内要处理)不支持Vue.use()加载方式

非vue官方库不支持new Vue()方式

每一个vue组件都是Vue的实例，所以组件内this可以拿到Vue.prototype上添加的属性和方法。

### $route和$router的区别

$router 为 `VueRouter 实例`，想要导航到不同 URL，则使用 $router.push 方法。

$route 为`当前 router 跳转对象`里面可以获取 name 、 path 、 query 、 params 等。

### 用户禁掉cookie，该怎么做兼容处理

用户禁掉了cookie是指禁掉了本地存储，所以localStorage和sessionStorage也不能使用。应该使用vuex进行通信

### vue-router是什么,哪几种模式？

Vue Router 是 Vue.js 官方的`路由管理器`。它和 Vue.js 的核心深度集成，让构`建单页面应用`变得易如反掌
<router-link>和<router-view>和<keep-alive>组件

`hash模式`，路径后加#，#后面的值变化，并不会导致浏览器向服务器发送请求，也不会刷新页面，每次hash值变化，还会触发`hashchange`事件，通过监听该事件来实现更新页面部分内容。hash的传参是基于url的，如果要传递复杂的数据，会有体积的限制

```js
function matchAndUpdate () {
   // todo 匹配 hash 做 dom 更新操作
}
window.addEventListener('hashchange', matchAndUpdate)
```

`history模式`:h5多了两个API，pushState，replaceState，通过这两个API改变url地址且不会发送请求。所以单也路由url不会多一个#，更加美观.

直接配置一下：`mode：history`

缺点：因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，需要服务器的支持，需要把所有路由都重定向到根页面。

```js
window.history.pushState(state,title,url)
//state：需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取
//title：标题，基本没用，一般传null
//url：设定新的历史纪录的url。新的url与当前url的origin必须是一样的，否则会抛出错误。url可以时绝对路径，也可以是相对路径。
//如 当前url是 https://www.baidu.com/a/,执行history.pushState(null, null, './qq/')，则变成 https://www.baidu.com/a/qq/，
//执行history.pushState(null, null, '/qq/')，则变成 https://www.baidu.com/qq/

window.history.replaceState(state,title,url)
//与pushState 基本相同，但她是修改当前历史纪录，而 pushState 是创建新的历史纪录

window.addEventListener("pospstate",function(){
 //监听浏览器前进后退事件，pushState与replaceState方法不会触发
})
window.history.back()//后退
window.history.forward()//前进
window.history.go(1)//前进一部，-2回退两不，window.history.lengthk可以查看当前历史堆栈中页面的数量

```

### vue-router有哪几种导航钩子

`全局导航钩子`:router.beforeEach(to,from,next)，前置钩子/后置钩子afterEach
`组件内的钩子`:beforeRouteEnter/beforeRouteUpdate/beforeRouteLeave

`beforeRouteEnter` 守卫 **不能** 访问 `this`，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。

`配置路由钩子:`beforeEnter/afterEach（在路由表中配置）

to（Route）:要进入到目标路由对象

from（Route）：当前导航正要离开的路由

- **next: Function**: 一定要调用该方法来 **resolve** 这个钩子。执行效果依赖 `next` 方法的调用参数。new Promise(function(resolve,reject){   }).then
- next函数必须执行 =>不执行 就会死在跳转的位置
- 如果直接执行next() => 表示一切正常 login => home 可以正常走   类似 callback()
- **next(false)** => 中断当前的导航 =>  login => home 不能正常走  停在login
- **next(地址)** => 强制将login=>home =>另一个地址 
  - **next()**: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 **confirmed** (确认的)。
  - **next(false)**: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 `from` 路由对应的地址。
  - **next('/') 或者 next({ path: '/' })**: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 `next` 传递任意位置对象，且允许设置诸如 `replace: true`、`name: 'home'` 之类的选项以及任何用在 [`router-link` 的 `to` prop](https://router.vuejs.org/zh/api/#to) 或 [`router.push`](https://router.vuejs.org/zh/api/#router-push) 中的选项。
  - **next(error)**: (2.4.0+) 如果传入 `next` 的参数是一个 `Error` 实例，则导航会被终止且该错误会被传递给 [`router.onError()`](https://router.vuejs.org/zh/api/#router-onerror) 注册过的回调。

**确保要调用 next 方法，否则钩子就不会被 resolved**

### 路由跳转的几种方式

`router-link`  声明式

1、不带参数

<router-link :to="{name:'home'}">

<router-link :to="{path:'/home'}">

2、带参数

<router-link :to="{name:'home'，params:{id:1}}" >

```
	// params传参数
　　// 路由配置 path: "/home/:id"
　　// 不配置path ,第一次可请求,刷新页面id会消失
　　// 配置path,刷新页面id会保留
　　// html 取参 $route.params.id
　　// script 取参 this.$route.params.id
```

<router-link :to="{name:'home'，query:{id:1}}" >

```
	// query传参数 (类似get,页面url后面会显示参数)
　　// 路由可不配置
　　// html 取参 $route.query.id
　　// script 取参 this.$route.query.id


```

`编程式路由`
this.$router.push() 这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。

this.$router.replace() 它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。

this.$router.go(n) 参数是一个整数，意思是在 history 记录中向前或者后退多少步 

### 动态路由？怎么获取传过来的动态参数

```
对path属性加上/:id。
router对象的params.id {{$route.params | json}}

```





### SPA单页面应用

`优点`：1、良好的交互体验，用户体验好，局部刷新，没有页面之间的切换，不会出现“白屏现象”

​	2、前后端分离模式

​	3、减轻服务器的压力，服务器只提供数据就可以，不用管展示逻辑和页面合成

`缺点`：1、**首屏加载慢**，：vue-router懒加载（路由被访问时才会加载对应组件）

​					CDN：把项目中比较大的第三包使用CDN链接

​					异步加载组件：和路由懒加载是一个道理

​					服务端渲染	

​	  2、**不利于SEO**：服务端渲染，路由采取h5 的history模式

​	  3、提高了页面的复杂性和逻辑的难度

| 单页面                                                       | 多页面                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 组成：一个外壳页面和多个页面片段组成                         | 组成：多个完整页面组成，记得是完整页面                       |
| css、js等资源：共用。只在外壳部分加载                        | css、js等资源：不共用。加载一个页面就去加载对应的资源        |
| url模式：[a.com/#/pageone](http://a.com/#/pageone) [a.com/#/pagetwo](http://a.com/#/pagetwo) | url模式：[a.com/pageone.html](http://a.com/pageone.html) [a.com/pagetwo.html](http://a.com/pagetwo.html) |
| 刷新方式：局部刷新                                           | 刷新方式：整页刷新                                           |
| 用户体验：页面切换速度快，用户体验较好                       | 用户体验：页面切换速度慢，影响用户体验。                     |
| 数据传递：容易                                               | 数据传递：依赖 url传参、或者cookie 、localStorage等          |
| 搜索引擎优化：	需要单独方案做，有点麻烦                   | 搜索引擎优化：比较容易                                       |
| 开发成本：较高，需要专业的框架                               | 开发成本：较低，但重复代码多                                 |
| 维护成本：相对容易                                           | 维护成本：相对复杂                                           |



### 父组件在monuted中获取后台数据X，子组件要在monuted中收到父组件中的数据X，并发送请求。
问子组件如何获取数据X

`获取不到`

![1583324625291](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1583324625291.png)

### 子组件为什么不可以修改父组件传递的prop

`Vue提倡单向数据流`,即父级 props 的更新会流向子组件,但是反过来则不行。这是`为了防止意外的改变父组件状态，使得应用的数据流变得难以理解`。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高

### Vue 的父组件和子组件生命周期钩子执行顺序是什么

渲染过程：

`父组件挂载完成一定是等子组件都挂载完成后`，才算是父组件挂载完，所以父组件的mounted在子组件mouted之后。

父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted

子组件更新过程：

影响到父组件： 父beforeUpdate -> 子beforeUpdate->子updated -> 父updted

不影响父组件： 子beforeUpdate -> 子updated

父组件更新过程：

影响到子组件： 父beforeUpdate -> 子beforeUpdate->子updated -> 父updted

不影响子组件： 父beforeUpdate -> 父updated

销毁过程：

父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed

### vue-cli项目目录解释

bablelrc=>存放 babel编译的配置信息 () => es6 => es5 

.editorconfig => 存放编辑器的配置信息

.gitignore => git忽略文件

index.html => 单页应用的html

package.json => 用于存放依赖信息 及 其他项目信息

README.md => 项目介绍信息 github上的页面信息

webpack.config.js => wepack工具的配置文件 => webpack是一个前端工程化的工具  编译代码 -压缩代码- 处理代码,其他....

webpack => 代码编译,打包 压缩

main.js => 整个项目的入口文件  => webpack  =>  build.js => index.html引入

App.vue => 一个组件 => 根组件

单文件组件 => 一个**`.vue`**文件就是一个组件 

### query参数，params参数

​	路由传参有两种方式：

​		query参数：

​			`不需要配置路由规则`

​			/login?a=b&foo=bar

​			在组件中获取参数：this.$route.query.xxx			

​		params参数：

​			`配置路由路径规则`

​			例如：/login/:abc

​			在组件中获取参数：this.$route.params.abc  获取通过props接收

​	不是必须的参数，配置为query参数

​	必须的参数，配置为params参数

​	query参数没有大小限制，严格来说url有带下限制

 	params刷新页面id还在params类似 post, 跳转之后页面 url后面不会拼接参数 , 但是刷新页面id 会消失  

### 购物车中的反选和全选是怎么实现的？

vue是数据操作视图，



点击单选给本条数据加一个状态ischecked=true,在计算属性中定义一个选中列表，遍历整个列表，如果ischecked为true，添加到选中列表，最后选中列表与整个列表的长度进行比较，true时长度一样全选

### nextTick

想要在修改数据之后马上操作数据影响的DOM。

 为了解决这个问题，Vue 提供了一个特殊的 API：$nextTick
该函数中的代码会确保本次数据更新视图之后才执行
简单理解：你可以把它当作一个定时器，它会在内部完成 DOM 修改之后触发调用

`dom更新后马上操作，需要使用随数据改变而改变的dom结构时`

Vue生命周期的created()钩子函数进行的DOM操作一定要放在nextTick()的回调函数中,因为c`reated()中使用的方法时，dom还没有渲染`，如果此时在该钩子函数中进行dom赋值数据（或者其它dom操作）时无异于徒劳，所以，此时this.$nextTick()就会被大量使用，而与created()对应的是mounted()的钩子函数则是在dom完全渲染后才开始渲染数据，所以在mounted()中操作dom基本不会存在渲染问题。


### 组件缓存

<keep-alive></keep-alive>

默认组件在切换的时候会销毁，组件缓存则不销毁

当`组件缓存之后，不在触发生命周期`，所以需要单独的配置动态缓存，但有两个特殊的生命周期依然触发activated，deactivad，用于缓存页面时做一些业务操作时。

​	activated：被keep-alive缓存的组件激活时调用

​	deactivated：被keep-alive缓存的组件停用时触发

keep-alive是Vue本身内置的一个组件，专门用来缓存组件的

​	app.vue  router-view就是一个动态组件，在外面包裹keep-alive，这样默认缓存全部

```vue
<keep-alive :include="cachePages">
	<router-view/>
</keep-alive>
data(){
return{
	cachePages:['组件name名(TabBar)']
	//若TabBar下的组路由也要缓存，在子路由容器外加keep-alive
}
}
```

默缓存所有缓存：

​	include可以配置哪些组件要缓存

​	exclude配置，默认缓存所有，不缓存exclude中的组件

 给keep-view 配置name

在vuex容器中存放添加缓存组件，移除缓存组件的方法（方便在其他组件中操作）。然后在组件使用的时候绑定容器中的缓存数组，

总结：

- 根据需要设置需要缓存的组件
- `缓存需要占用更大的内容，当缓存组件过多的时候容易造成页面卡顿`
- 把不需要缓存的组件排除缓存

### vue混入模式有了解吗？

minix 将代码块进行封装

## 小程序

规则：小程序同一个目录下面index.xwss自动找同名的index.wxml文件

特别：小程序里面没有ul li div标签

`view 相当于html中的div`，在小程序中叫组件。把组件当做标签使用

`input没有边框线`

form默认为行内元素

navigator url=’./index/index‘页面跳转 ，点击之后跳转

### 目录结构

app.js 入口文件

app.json 配置

app.wxss 样式，不能和css划等号

project.config.json 项目的配置文件，比如appID

### app.json

配置文件，字段为双引号，数组末尾成员没有逗号

pages: 所有的页面，相对路径，可省略后缀

window：界面窗口的显示配置

​	navigationBar配置

tabBar：数组的形式 "list":[{},{},{}],position：默认bottom;当设置top时，图标没有，下横线没有；最少两个，最多五个

​	对象里配置：

​	text：选项文字

​	iconPath：图标路径，相对路径

​	selectedIconPath: 当前选择项的图标路径

​	pagePath：选项卡点击后的页面地址

### 轮播图

```html
<swiper>
    <swiper-item>
    	<image src=""></image>
    </swiper-item>
    
</swiper>
//根据官方文档设置是否自动轮播、切换事件等 autoplay，interval
```

### 适配，750rpx

UI出图为750px，手机会自动找到当前屏幕宽度下 1rpx 背后代表的值；

### 小程序预览需要设置什么？

打包后不超过2M，若超过，忽略图片进行打包

在project.config.json进行配置忽略，packOptions对象，ignore数组

```js
"packOptions": {
		"ignore": [
			{
				"value": "static/images",
				"type": "folder"
			},
			{
				"value": "static/uploads",
				"type": "folder"
			}
		]
	},
```

图片：项目中图片，字体文件，是后台请求回来的网络地址；`tabBar的图标不能被设置忽略：要求不能使用网络地址，只能使用本地图片`

### 图片问题

在wxss内使用相对路径会报错，`使用网络地址`

`tabBar不支持网络图片`

- 搭建静态页：可以使用本地图片；

- 后台数据请求：**网络地址或者字体图标文件地址**

  - wxml：可以使用相对路径，和网络地址

  - wxss：使用base64或网络地址

    

### 发布

- 1.上传代码到小程序管理后台（专门的一个开发人员）
- 2.设置体验本版，进行测试；（测试人员）
- 3.测试完毕后，提交审核（给微信小程序一些人）；
- 4.审核成功后，需要我们自己点发布；

### V2样式问题

设置新样式不会真实的覆盖掉内置的样式

解决：提高css权重、不使用v2版本（在app.json中删除）

### 多个标签被同时循环或者被判断if ，应该如何设置

1、使用wx:if

2、使用<block>将循环或者判断的组件包起来，在block上写wx语法

### 事件回调函数

- ind事件类型=”事件执行函数“   bind:tap
- 事件对象：e
- **bind:事件类型=”事件执行函数“   (推荐使用，清晰看见事件类型)**
- 事件类型：
  - tap：手指点击屏幕
  - focus：获取焦点
  - blur：失去焦点

### 原生小程序的事件回调函数可以传入参数么？如何设置获取组件上自定义属性？

- 不能传入参数：语法设置不能传入；
- 自定义数据：
  - 如何设置：`data-xxxx`
  - 获取：事件执行的回调，需要事件对象；`e.target.dataset`获取自定义属性的（键值对）
  - 意思：**`相当于是我们给组件通过另外的形式传入 参数`**
  - `实现数据与视图的同步更新`，使用this.setData({要更新的数据})

### 请求 wx:request

平台：配置 request合法域名请求；

本地开发：不校验合法域名，注意上线前，要把域名换回来

```js
wx.request({
    url: "http://127.0.0.1:3000",
    method: "GET",
    data: {},
    success: function() {},
    fail: function() {}
});
```

### 事件执行的三个阶段？为什么要阻止冒泡？

事件执行三个阶段：捕获阶段、目标阶段、冒泡阶段；

事件默认是在冒泡阶段执行

若不阻止：

- 子组件注册了tap事件
- 父级注册了tap事件
- 当我们触发子级，父级也会跟着触发；
  - 用户知道自己点对了：点的就是子级
  - 父级跟着触发的这个情况：**给用户体验不好**，阻止冒泡！

`阻止冒泡语法`：同时监听用户的触发行为，也阻止冒泡；

- catch:事件类型=“事件执行函数”
- catch事件类型=“事件执行函数”

### 小程序生命周期

小程序中将生命周期分成两类，分别是`应用级别App`和`页面级别Page`。

本质：内置了一些函数，当到达特定节点的时候，程序监听到某一节点，执行函数

`生命周期app`

**`App() 必须在 app.js 中调用，必须调用且只能调用一次`**

```js
App({
  // 当第一次启动时，只会执行一次；就是启动了就执行；
   //有些逻辑不能写在onLaunch里面，因为只会在开启的时候才会执行一次！！
  onLaunch: function() {
    console.log(1);
    wx.reques();
  },

  // 前台运行时
  onShow: function() {
    console.log(2);
  },
  // 后台运行时，切后台，小程序并没有被关闭，关机，内存不够用时，微信会自动选择关闭小程序，切后台超过一定时间
  onHide: function() {
    console.log(3);
  },

  // 小程序抛出错误时，捕获错误时
  onError: function() {
    console.log("error");
    // 给用户：弹窗提醒：我们小程序出错了~~~~~
  },

  // 小程序启动时且同时，设置的页面找不到时执行；启动后，再次找不到页面，这个函数不执行；
  onPageNotFound: function() {
    console.log("没有找到页面");
  }
})
```

`生命周期page`

```js
Page({
  // 页面加载完时
  onLoad: function() {
    console.log("page-页面加载了");

  },
  // 页面显示时
  onShow: function() {
    console.log("page-页面显示");
  },
  // 页面渲染完成时
  onReady: function() {
    console.log("page-页面渲染完成时");
  },

  // 页面隐藏时
  onHide: function() {
    console.log("page-页面被隐藏的时候");
  },
})
点击navigator

页面转跳，当前页面只是隐藏；并没有被销毁;
`点击返回，只是会执行 onShow，可以理解为页面只是被隐藏了，页面不会加载和渲染`
在小程序内，只要页面看不见了，就会触发onHide
```

### 场景值

打开方式的不同，会有一个特定的值，可以用来推广

- 打开方式：扫一扫、搜索、转发；哪种统计次数更多的话，调整公司策略；
- onLaunch(res) :  `res.scene`
  - 事件对象获取场景值；
  - 打开方式业务在onLaunch写；单独写函数；在onLaunch调用；
  - 通过与后台的配合，可以将场景值传给后台，在后台进行比较，确定最多的，调整推广方式

### 地址参数

`使用场景`：

进入某个页面，看产品的详情

产品的详情：布局都是一样，这个页面的结构都是一样

不一样：页面内的数据

如何解决：进入这个页面的时候，给这个页面传入一个参数；向后台请求不同的数据；

`语法：` 在onLoad  函数 写形参query 获取页面的参数

<navigator url="../03_live/index?id=11&name=zs">去一个页面</navigator>

```js
onLoad(query) {

    // 在onLoad  函数 写形参query 获取页面的参数，
    // 返回一个对象，传入参数的键值对；
    console.log(query);
    
    // 业务：向后台请求数据...
    // wx.request({..})
},
```

### 微信API

顶级对象为：wx

wx.showLoading() 显示加载框

wx.hideLoading() 隐藏加载框

wx.showModal() 显示一个弹出框

wx.showToast() 信息提示

### 使用npm

npm下载包之后要配置才能使用

1、工具=>构建npm

2、详情=>本地设置=>使用npm模块

### wxs

不改变data里的数据，还想渲染出特定格式的数据，`像vue中filter过滤器`

原因：小程序设计的时候，渲染层和逻辑层是分离的

渲染层：wxml  wxss wxs  	可以在wxml里面直接使用 wxs 里面定义的属性和方法

```js
<!-- 使用wxs: 渲染层的 JS -->
<wxs module="obj">

  module.exports = {
    str_change:function(str){
      return "***_"+ str + "_***";
    }
  }

</wxs>


<view >{{a}}</view>
<view >{{obj.str_change(b)}}</view>
```

`公共wxs使用`

- - 1.创建单独的wxs文件，后缀.wxs
  - 2.通过wxs 标签src 属性进行引入 ，module="导出对象的变量名"
  - 3.使用：`<view >{{zhc.str_change(a)}}</view>`
- 好处：相对于就是页面的过滤器：不改变原页面的数据，但是可以进行简单的逻辑的格式的展示；

### 模板

- 小程序提供了模板功能，使用模板可以将页面中的公共部分提取出来，实现**复用**的效果。
- 复用：
  - 组件：有业务逻辑在里面的；
  - 模板：只是简单的展示，复用；没有复杂的逻辑；
- 基础语法：
  - 1.在wxml内 使用`template`标签；必须有`name属性`；标签内就是模板；
  - 2.其他页面wxml文件 进行`import`标签导入（src）；
  - 3.在导入的wxml内使用 `template`标签使用模板( is属性)

### 设置下拉刷新

1、在json文件中配置enablePullDownRefresh为true(app.json中在window中设置enablePullDownRefresh,此效果作用于全局)。

2、在js文件中实现onPullDownRefresh方法,在网络请求完成后调用wx.stopPullDownRefresh()来结束下拉刷新。

## 框架

### MVVM和MVC的区别

`MVC`：MVC模式可以这样理解，Controller负责将Model的数据用View显示出来，换句话说就是在Controller里面把Model的数据赋值给View。

`Model（模型）`：是应用程序中用于处理应用程序数据逻辑的部分。存放数据

`View（视图）`：是应用程序中处理数据显示的部分。

`Controller（控制器）`：是应`用程序中处理用户交互的部分`。
通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据

将html看成view;js看成controller，处理用户与应用的交互，响应对view的操作（对事件的监听），调用Model对数据进行操作，完成model与view的同步（根据model的改变，通过选择器对view进行操作）;将js的ajax当做Model，从服务器获取数据，MVC是单向的。

`MVVM`：它实现了View和Model的自动同步，也就是当Model的属性改变时，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变，MVVM是双向的。代表：vue

MVVM 是 Model-View-ViewModel 的缩写。

`Model`代表`数据模型`，也可以在Model中`定义数据修改和操作的业务逻辑`。

`View`代表UI 组件，它负责`将数据模型转化成UI 展现出来`。

ViewModel `监听模型数据的改变和控制视图行为、处理用户交互，`简单理解就是一个同步View 和 Model的对象，连接Model和View。

在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，`Model 和 ViewModel 之间的交互是双向的`， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。

`ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来`，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。

## webpack

### export 和export default 的区别

1、export和export default均可以用于导出常量、函数、文件、模板等

2、在一个文件或模块中，export（导出）和import（导入）可以有多个，export default（导出）仅有一个

3、通过export方式导出，在导入时要加{ }，export default不需要

4、export default（默认输出）

### module.export 和 require的区别？

node里的模块的使用，require导入的内容是module.export指向的内存块。export只是module.exports的引用，辅助后面添加内容用的。

### 你对webpack的认识

静态模块打包器

webpack是把项目当做一个整体，通过一个给定的主文件，将从这个文件开始找到你项目的所有依赖文件，使用loader出来他们，最后打包成一个或多个浏览器可识别度js文件

### 如何配置webpack

entry: 用来写入口文件，它将是整个依赖关系的根。当我们需要多个入口文件的时候，可以把entry写成一个对象。

output: 即使入口文件有多个，但是只有一个输出配置，如果你定义的入口文件有多个，那么我们需要使用占位符来确保输出文件的唯一性。

### webpack打包原理

webpack由四个核心概念：入口(entry)、出口(output)、loader、插件(plugins)。

entry：表示webpack打包开始的入口文件。
output：标识webpack打包结束的导出文件（路径和文件名）。
loader：转换非JavaScript文件（webpack只能识别js文件），如Typescript、css、scss等，可配置对某一文件类型做具体的loader转化。
plugins：可以执行范围更广的任务（后续更新……）
module：可以选择development和production模式，webpack内部会进行相应的优化。

### webpack中的Loader的作用是什么

loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块

1、实现对不同格式的文件的处理，比如说将scss转换为css，或者typescript转化为js
2、转换这些文件，从而使其能够被添加到依赖图中

`这里介绍几个常用的loader：`
babel-loader： 让下一代的js文件转换成现代浏览器能够支持的JS文件。
babel有些复杂，所以大多数都会新建一个.babelrc进行配置
`css-loader,style-loader`:两个建议配合使用，用来解析css文件，能够解释@import,url()如果需要解析less就在后面加一个less-loader
file-loader: 生成的文件名就是文件内容的MD5哈希值并会保留所引用资源的原始扩展名
url-loader: 功能类似 file-loader,但是文件大小低于指定的限制时，可以返回一个DataURL事实上，在使用less,scss,stylus这些的时候，npm会提示你差什么插件，差什么，你就安上就行了

### webpack中的Plugins的作用是什么

可以处理各种任务，从打包优化和压缩，一直到重新定义环境中的变量

插件

### webpack中什么是bundle,什么是chunk,什么是module

1、bundle是由webpack打包出来的文件，

2、chunk是指webpack在进行模块的依赖分析的时候，代码分割出来的代码块。

3、module是开发中的单个模块。

4、chunk 打包后变成bundle.

### webpack实时打包

使用webpack-dev-serve 安装=》配置

webpack.config.js  host主机名，port端口号，open自动开启 compress:true 对网络请求文件进行压缩处理

package.json  serve:"webpack-dev-server"

## git

### git 和svn的区别，并说一下常见的git命令

1、Git是开源的分布式版本控制系统，SVN（Subversion）是集中式版本控制.

2、Svn将所有的内容都被存放在中心节点（中心服务器）上，一旦中心服务器出现故障，都将不能使用。

3、Svn更加安全，代码一致性高，但服务器压力大。

4、Git代码保密性差，但速度快、灵活

**git branch feature-A**/创建分支，这里的feature-A是我的分支名

 **git checkout feature-A**//将当前分支切换到该分支

`新建分支并切换到该分支`

$ git checkout -b <分支名称>

 `列出所有本地分支`
$ git branch

`列出所有远程分支`
$ git branch -a

工作区=》暂存区=》仓库

放弃工作区的修改

git checkout .（放弃所有） 

放弃暂存区的修改

git reset HEAD 
git checkout .

从仓库中恢复

`git reset –hard 版本号`  版本回退

master主分支，dev开发分支、bug临时分支

### git代码合并时出现冲突

git merge 分支名

典型冲突发生的原因`：两个分支下都是修改了同一个地方`

解决：

​	1、打开有冲突的文件

​	2、根据实际情况手动修改

​	3、保存修改，并提交git commit -a -m ""

### 项目上线之后出现bug时，在项目开发时你是怎么做的

在项目上线运行之后，用户报出bug时，我们一般会拉出``一个新的分支来解决这个bug`。 我们假设出bug时一般会附一个bug编号，如1034，此时，我们要去修改代码以解决这个bug，应该怎么做呢？

```js
// 当前你正在dev分支开发
// 从目前分支回到master分支。
git checkout master
// 在master分支上拉出新分支,分支名中包含了bug及bug的编号
git checkout -b bug1034
// 修改代码，修复bug。希望你可以很顺利地解决这个bug
// 解决bug之后，回到master分支
git checkout master
// 在master分支上合并bug1034分支
git merge bug1034
// 准备再次上线 ...
// 你也可以选择删除这个bug分支
git branch -d bug1034
//  回到dev分支，继续开发（搬砖）
git checkout dev

```

### 实际工作中的git流

![1584372873469](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1584372873469.png)

## 其他

### 谈谈用户从输入url到页面渲染完成发生了什么过程

①浏览器的地址栏输入URL并按下回车。

②浏览器`查找当前URL的DNS缓存记录`。

③DNS解析URL对应的IP。

④`根据IP建立`有web服务器的`TCP连接`（三次握手）。

⑤HTTP发起请求。

⑥服务器处理请求，浏览器接收HTTP响应。

⑦渲染页面，构建DOM树。

⑧关闭TCP连接（四次挥手）。

### 三次握手是什么

原因：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

- 浏览器:我说的话，你听见了么？
- 服务器：听见了，我说的你听见了么？（回复A的问题，提出自己的问题）；
- 浏览器：听见了，我们开始说话吧。

### 四次挥手

​	浏览器：数据传送完成，我准备断开连接

​	服务器：关闭请求已经收到，但可能还有数据没有完全传送，数据传输完成了就告诉你

​	服务器：现在可以断开了。

​	浏览器：好的，没有得到响应之后，断开

### 谈一谈你对http的理解

1、`http（超文本传输协议）`其处于OSI7层模型中的应用层，OSI7层模型分别为应用层-》表示层-》会话层-》传输层-》网络层-》数据链路层-》物理层

2、http事物是指从`客户端（IE）向服务器端发送http请求，再由服务器将响应的内容返发回给客户端的一个过程`。

3、http中的方法分为5种：增（PUT）、删(DELETE)、改(POST)、查(GET)、HEAD

4、（TCP）三次握手完成之后建立http请求，请求完四次挥手

### 浏览器的渲染过程

解析HTML生成DOM树。

解析CSS生成CSSOM规则树。

将DOM树与CSSOM规则树合并在一起生成渲染树。

遍历渲染树开始布局，计算每个节点的位置大小信息。

将渲染树每个节点绘制到屏幕

### 主流浏览器内核与那些，对应的私有属性css前缀是什么？

mozilla内核 (firefox,flock等) -moz 

webkit内核(safari,chrome等) -webkit       

opera内核(opera浏览器) -o 

trident内核(ie浏览器) -ms 

浏览器的兼容性问题，不同的浏览器需要添加不同的前缀
`webkit（谷歌） moz（火狐） ms（IE） o（欧朋）`

### 前端如何进行SEO优化

1、合理的使用关键字，title、description、keyword。title值强调重点即可；description把页面内容高度概括，不可过分堆砌关键词；keywords列举出重要关键词。

2、语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页

3、重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，保证重要内容一定会被抓取

4、重点内容不要用js输出，爬虫不会执行js获取内容

5、非装饰性图片必须加alt

6、提高网站速度：网站速度是搜索引擎排序的一个中

### 前后端分离的项目如何SEO？？？

1、多页面

2、在服务端生成基于数据组装好的html

### 一次性插入1000个div，如何优化插入的性能

1、使用Fragment

```js
var fragment = document.createDocumentFragment();
    fragment.appendChild(elem);
```

2、向1000个并排的div元素中，插入一个平级的div元素，如何优化插入的性能 

- 先display:none 然后插入 再display:block

- 赋予key，然后使用virtual-dom，先render，然后diff，最后patch

- 脱离文档流，用GPU去渲染，开启硬件加速

  

### 如何在浏览器端中进行大数据的存储优化和检索优化？？？

合理建立索引，对数据库分库分表，拆分历史库，优化查询存储过程
应用层做缓存，数据层做分布式并发查询

### 为什么利用多个域名来存储网站资源会更有效

① CDN缓存更方便 ②突破浏览器并发限制③节约cookie带宽④节约主域名的连接数，优化页面响应速度⑤防止不必要的安全问题

### 负载均衡的理解

负载均衡：是将`负载（工作任务，访问请求）进行平衡、分摊到多个操作单元（服务器，组件）上进行执行`。是解决高性能，单点故障（高可用），扩展性（水平伸缩）的终极解决方案

负载均衡在七层网络协议上

TELNET、HTTP、FTP、NFS、SMTP、DNS等属于第七层应用层的概念。

TCP、UDP、SPX等属于第四层传输层的概念。

IP、IPX等属于第三层网络层的概念。

ATM、FDDI等属于第二层数据链路层的概念。

![img](https://img2018.cnblogs.com/blog/573911/201905/573911-20190528140203987-590014396.png)

`应用层：http重定向协议实现负载均衡`

原理：据用户的http请求计算出一个真实的web服务器地址，并将该web服务器地址写入http重定向响应中返回给浏览器，由浏览器重新进行访问。

`应用层：DNS域名解析负载均衡`

原理：：在DNS服务器上配置多个域名对应IP的记录。例如一个域名www.baidu.com对应一组web服务器IP地址，域名解析时经过DNS服务器的算法将一个域名请求分配到合适的真实服务器上。

`应用层：反向代理负载均衡`

原理：反向代理处于web服务器这边，反向代理服务器提供负载均衡的功能，同时管理一组web服务器，它根据负载均衡算法将请求的浏览器访问转发到不同的web服务器处理，处理结果经过反向服务器返回给浏览器。

`网络层：IP负载均衡`

原理：在网络层通过修改目标地址进行负载均衡。

`链路层：数据链路层负载均衡`

原理：在数据链路层修改MAC地址进行负载均衡

<https://blog.csdn.net/mengdonghui123456/article/details/53981976?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task>

### 常见的http状态码

· 200 - 请求成功

· 301 - 资源（网页等）被永久转移到其它URL

  302-重定向，需要进一步的操作以完成请求

  400 请求参数错误

  401 - 没有权限（未授权），没有token

  403 -没权限，token失效（服务器拒绝请求）

  405 -接口使用错误

· 404 - 请求的资源（网页等）不存在

· 500 - 内部服务器错误

  503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）

### CDN加速服务

- CDN 主要针对的静态资源
- 我们可以把我们自己的代码放到 CDN 上
- 也可以使用一些免费的第三方 CDN 服务
  - 一般提供的都是一些常用的第三方包的 CDN 服
  - 例如 bootcdn
- 我们最好把项目中比较大的第三方包都使用 CDN 链接
  - 不仅能提高构建的速度
  - 还能提高页面的响应速度
- 当我们在项目中使用 CDN 链接之后，就没必要下载打包第三方包了
- CDN相当于把一个文件放在了全国各地,然后你离哪里近,就从哪里调拨给你，用更快的方式获取到文件资源

1、之前加载过直接在缓存中存在

2、就近原则

### CommonJS, AMD, CMD，UMD的区别？？？

commonJs同步模块定义

AMD异步模块定义

CMD通用模块定义

UMD它没有自己专有的规范，是集结了 CommonJs、CMD、AMD 的规范于一身

AMD和CMD的区别：

1. 对于依赖的模块，`AMD 是提前执行，CMD 是延迟执行`。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible（尽可能的懒加载，也称为延迟加载，即在需要的时候才加载）。
2. `CMD 推崇依赖就近，AMD 推崇依赖前置。`虽然 AMD 也支持 CMD 的写法，同时还支持将 require 作为依赖项传递，但 RequireJS 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。
3. AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。

### 图片的懒加载和预加载

`预加载`：提前加载图片，当用户需要查看时可直接从`本地缓存中渲染`

`懒加载`：用户在使用的时候才加载数据，不一开始就加载完。主要目的是作为服务器前端的优化，减少请求数或延迟请求数。

原理：懒加载是把图片地址设置给自定义属性比如data-src 监听到要加载了再设置给src

两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 `懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力`。

 ### 手机端适配遇见的兼容性问题

​		使用 $(window).resize(...) 无效,使用 window.onresize = function () {...} 即可

​		gif动图附近会闪烁,进可能减少gif动图帧数量，或直接忽略这些卡顿的手机

​		<`button></button>`元素一定要写上type属性不然会默认提交表单

android

​	1、`穿透问题`  解决：1、禁掉原生的监听 2、弹框打开的时候，让底层的整个body进行隐藏（overflow：hidden）

​	弹层的关闭事件容易触发弹层关闭后下一层的事件所以要给弹层关闭事件加上event.preventDefault()

​	弹层弹出后不允许屏幕滚动给弹层加mousemove事件event.preventDefault()

IOS：

​	1.苹果手机固定定位有bug 检查html和body是不是设置了overflow-x:hidden;

​	2.手机页面里可滚动内容滚动不流畅，手指滑动多少页面就只滚动多少，没有弹性效果 ：-webkit-overflow-scrolling : touch;

​	3.iphoneX适配方法： mate中增加 viewport-fit=cover（页面内容显示在整个屏幕）同时页面还要设置如下

```css
	body { 

    padding-top: constant(safe-area-inset-top);  //为导航栏+状态栏总高度（88px）

    padding-left: constant(safe-area-inset-left);    //如果未竖屏时，为0  

    padding-right: constant(safe-area-inset-right);   //如果未竖屏时，为0  

    padding-bottom: constant(safe-area-inset-bottom);   //为底部圆弧高度（34px）

}
```
### restful API

`restful`就是一套接口设计规范，用来规范我们的api的一种约束。是前端后端分离的产物

`api`：get、post、put、patch、delete

`规范：`1、使用小写字母	2、不使用文件拓展名	3、不要在末尾使用/...

​	 4、使用http状态码定义api执行结果  

### 客户端页面加载用时很长，如何查询原因，如何解决？

1、在network中查看是哪部分资源造成的数据过慢

2、如果是前端页面请求的慢。进行前端页面的优化。GZIP，懒加载，按需加载，CDN服务

3、如果是接口请求过慢，如果是数据大，做分页请求，如果是数据小，可能是后端逻辑有问题。

### 用过服务端渲染吗

在服务端生成基于数据封装好的html

### 多数据同时进行双向数据绑定？？？

### 常见的兼容性问题

1、 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一

2、 IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。

3、 上下margin重合问题

ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。

解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。

4、 ie6对png图片格式支持不好(引用一段脚本处理)

### 前后端联调

1. 项目是前后端分离的项目；后端负责提供数据接口，前端负责页面。
2. 一般接口完成之后，后端会给一份接口文档，包含接口地址，请求类型，请求的参数，可能的数据返回。
3. 部分后端同学可能不写文档，会进行口头沟通。口头沟通的时候需要记录必要的信息。
4. 联调的时候最好是工作时间（免得晚上，别人下班了），因为可能涉及到沟通。
5. `最好开发之前想好你需要哪些数据，然后和后端提前沟通一下。`避免一下你需要的数据，后端没有开发，导致项目工期延误

### webSocket

WebSocket 是一种数据通信协议，类似于我们常见的 http

`区别：`

WebSocket的通信是双向的，http是单向的（请求+响应，没有请求也就没有响应，通信只能由客户端发起）

浏览器为 HTTP 通信提供了 `XMLHttpRequest` 对象，同样的，也为 WebSocket 通信提供了一个通信操作接口：`WebSocket`

webSocket的特点：

1、`服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话`，属于[服务器推送技术](https://en.wikipedia.org/wiki/Push_technology)的一种

2、建立在 `TCP 协议`之上，服务器端的实现比较容易。

3、与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段（第 1 次建立连接）采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

4、数据格式比较轻量，性能开销小，通信高效。

5、可以发送文本，也可以发送二进制数据。

6、`没有同源跨域限制，客户端可以与任意服务器通信`。

7、协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL。

8、浏览器专门为 WebSocket 通信提供了一个请求对象 `WebSocket`

webSocket通信模型：拨号（建立连接）、通话（双向通信）、结束通话（关闭连接）

`源码实现：`

```js
// WebSocet 通信模型

      // 1. 拨打电话（建立连接）
      // 注意：wss://echo.websocket.org 是一个在线的测试接口，仅用于 WebSocket 协议通信测试使用
      var ws = new WebSocket("wss://echo.websocket.org");

      // 当连接建立成功，触发 open 事件
      ws.onopen = function(evt) {
        console.log("建立连接成功 ...");

        // 连接建立成功以后，就可以使用这个连接对象通信了
        // send 方法发送数据
        ws.send("Hello WebSockets!");
      };

      // 当接收到对方发送的消息的时候，触发 message 事件
      // 我们可以通过回调函数的 evt.data 获取对方发送的数据内容
      ws.onmessage = function(evt) {
        console.log("接收到消息: " + evt.data);

        // 当不需要通信的时候，可以手动的关闭连接
        // ws.close();
      };

      // 当连接断开的时候触发 close 事件
      ws.onclose = function(evt) {
        console.log("连接已关闭.");
      };
```

### Socket.io

Socket.io 和 WebSocket 就好比它就好比 axios 和 XMLHTTPRequest 的关系。

建立连接：

```js
const socket = io("连接地址");
```

发送数据：

```js
// 发送指定类型的消息
// 数据可以是任何类型
socket.emit("消息类型", 数据);
```

接收消息：

```js
// 消息类型
// 回调函数参数获取消息数据
socket.on("消息类型", data => {
  console.log(data);
});
```

> 消息类型由后端给出，他会告诉你收发消息的类型，就好比 HTTP 接口中的请求路径一样。


### 优雅降级和渐进增强

渐进增强（Progressive Enhancement）：
一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。

优雅降级（Graceful Degradation）：

一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。

其实渐进增强和优雅降级并非什么新概念，只是旧的概念换了一个新的说法。在传统软件开发中，经常会提到向上兼容和向下兼容的概念。渐进增强相当于向上兼容，而优雅降级相当于向下兼容。